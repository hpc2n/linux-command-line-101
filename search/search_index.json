{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the course: Linux command line 101 \u00b6 This material Here you will find the content of the workshop \u201cCommand line 101\u201d. Documentation about Linux at some of the Swedish HPC centres HPC2N: https://docs.hpc2n.umu.se/tutorials/linuxguide/ UPPMAX: https://docs.uppmax.uu.se/getting_started/linux/ LUNARC: https://lunarc-documentation.readthedocs.io/en/latest/guides/linux/linux_basics_intro/ PDC: https://support.pdc.kth.se/doc/support-docs/basics/introduction/#basic-linux-for-new-hpc-users Documentation from Software Carpentry: https://swcarpentry.github.io/shell-novice/ Prerequisites You need access to a Linux system. You will use your own computer or any other computer (including computing access at computing centers) you have access to and that runs Linux. The course project will be on Tetralith, ONLY for those that do not have other access to a computer that runs Linux . For those using Tetralith, there is a Get started guide for NSC here . Learning outcome This NAISS course aims to give a brief, but comprehensive introduction to the Linux operating system. What is Linux and why should I use it? You will learn about the command line interface (CLI) navigating and modifying the file tree ls mkdir cd mv editors on the Linux system pipes, sorting, filters redirection pipes etc. patterns scripting some handy hints and tricks This course will consist of lectures and type-alongs, as well as a few exercises where you get to try out what you have just learned. This is the fifth instance of this course, and it has been somewhat reworked based on previous participant input. We would be grateful if you will fill the evaluation survey so we can further improve the course: https://forms.office.com/e/NFR7fyhc3i Cluster-specific approaches The course is given by application experts from several NAISS branches. It is agnostic, but the course project for those who do not have their own Linux access will the NAISS system \u201cTetralith\u201d. There is a Get started guide for NSC here . The login node for Tetralith is tetralith.nsc.liu.se . It looks like this when I ( x_birbr on \u201cTetralith\u201d) login the first time from my computer \u201cdefiant\u201d: bbrydsoe@defiant:~$ ssh x_bibr@tetralith.nsc.liu.se The authenticity of host 'tetralith.nsc.liu.se (2001:6b0:17:140::1:10)' can 't be established. ECDSA key fingerprint is SHA256:dwFmOFzy59e+OdZmMLAW3fj+GeMGACYwjPgc7LKZgSU. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added ' tetralith.nsc.liu.se,2001:6b0:17:140::1:10 ' ( ECDSA ) to the list of known hosts. Password: Verification code: The verification code it asks about is a 2FA that you need to set. See here: https://www.nsc.liu.se/support/2fa/ . Important info \u00b6 There is an \u201cimportant info\u201d page for this course, containing info on the course project, login info for Tetralith, etc. It can be found here: https://umeauniversity.sharepoint.com/:w:/s/HPC2N630/IQBsH-Pe_wARRZXveB6zeM63AffGTwAMlQolvDfpaNaZJJk?e=EpDuCE There is a Q/A page for use during the lectures. Since the lectures are recorded, you may get recorded if you ask questions in the Zoom, but you can always write questions on the Q/A and get answers there. It also has the advantage that you can go back and look at the answers later. The Q/A page can be found here: https://umeauniversity.sharepoint.com/:w:/s/HPC2N630/IQCI0r5NQ-gWQJI4oBi6trbXAWlznFWAQaBab_i5erb9VME?e=HyfiWp Preliminary schedule \u00b6 Time Topic Activity Teacher 9:00 Welcome+Syllabus Joachim 9:10 What is Linux? Why should you use it? Lecture Joachim 9:20 The command line (CLI) Lecture+code along Sahar 9:30 Navigating the File System Lecture+code along+exercise Sahar 10:00 Modifying the file tree Lecture+code along+exercise Sahar 10:25 BREAK 10:40 Editors Lecture+code along Pedro 10:50 Piping and filters Lecture+code along+exercise Pedro 11:10 Finding patterns Lecture+code along+exercises Pedro 11:25 Scripting Lecture+code along Pedro 11:40 Hints and tricks Lecture+code along Joachim 11:50 Summary Joachim 12:00 END of course Preparations \u00b6 In order to type along and do the exercises, please prepare your course environment now: Login to the system you are using (Tetralith, your own computer, other system) Create a directory to work in ( mkdir intro-linux ) and then switch to it ( cd intro-linux ) NOTE If you are working on Tetralith, first switch to your working directory: cd /proj/spring-courses-naiss/users/YOUR-USERNAME Download the exercises with wget https://github.com/hpc2n/linux-command-line-101/raw/refs/heads/main/exercises.tar.gz Check the contents of the file tar tzvf exercises.tar.gz Extract the exercises with tar xzvf exercises.tar.gz Enter the directory that was created: cd exercises Remark: By default the utility wget is not installed on a Mac. You can download from the website: https://github.com/hpc2n/linux-command-line-101/blob/main/exercises.tar.gz and move the file: mv ~/Downloads/exercises.tar.gz . instead of step 3.","title":"Home"},{"location":"#welcome__to__the__course__linux__command__line__101","text":"This material Here you will find the content of the workshop \u201cCommand line 101\u201d. Documentation about Linux at some of the Swedish HPC centres HPC2N: https://docs.hpc2n.umu.se/tutorials/linuxguide/ UPPMAX: https://docs.uppmax.uu.se/getting_started/linux/ LUNARC: https://lunarc-documentation.readthedocs.io/en/latest/guides/linux/linux_basics_intro/ PDC: https://support.pdc.kth.se/doc/support-docs/basics/introduction/#basic-linux-for-new-hpc-users Documentation from Software Carpentry: https://swcarpentry.github.io/shell-novice/ Prerequisites You need access to a Linux system. You will use your own computer or any other computer (including computing access at computing centers) you have access to and that runs Linux. The course project will be on Tetralith, ONLY for those that do not have other access to a computer that runs Linux . For those using Tetralith, there is a Get started guide for NSC here . Learning outcome This NAISS course aims to give a brief, but comprehensive introduction to the Linux operating system. What is Linux and why should I use it? You will learn about the command line interface (CLI) navigating and modifying the file tree ls mkdir cd mv editors on the Linux system pipes, sorting, filters redirection pipes etc. patterns scripting some handy hints and tricks This course will consist of lectures and type-alongs, as well as a few exercises where you get to try out what you have just learned. This is the fifth instance of this course, and it has been somewhat reworked based on previous participant input. We would be grateful if you will fill the evaluation survey so we can further improve the course: https://forms.office.com/e/NFR7fyhc3i Cluster-specific approaches The course is given by application experts from several NAISS branches. It is agnostic, but the course project for those who do not have their own Linux access will the NAISS system \u201cTetralith\u201d. There is a Get started guide for NSC here . The login node for Tetralith is tetralith.nsc.liu.se . It looks like this when I ( x_birbr on \u201cTetralith\u201d) login the first time from my computer \u201cdefiant\u201d: bbrydsoe@defiant:~$ ssh x_bibr@tetralith.nsc.liu.se The authenticity of host 'tetralith.nsc.liu.se (2001:6b0:17:140::1:10)' can 't be established. ECDSA key fingerprint is SHA256:dwFmOFzy59e+OdZmMLAW3fj+GeMGACYwjPgc7LKZgSU. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added ' tetralith.nsc.liu.se,2001:6b0:17:140::1:10 ' ( ECDSA ) to the list of known hosts. Password: Verification code: The verification code it asks about is a 2FA that you need to set. See here: https://www.nsc.liu.se/support/2fa/ .","title":"Welcome to the course: Linux command line 101"},{"location":"#important__info","text":"There is an \u201cimportant info\u201d page for this course, containing info on the course project, login info for Tetralith, etc. It can be found here: https://umeauniversity.sharepoint.com/:w:/s/HPC2N630/IQBsH-Pe_wARRZXveB6zeM63AffGTwAMlQolvDfpaNaZJJk?e=EpDuCE There is a Q/A page for use during the lectures. Since the lectures are recorded, you may get recorded if you ask questions in the Zoom, but you can always write questions on the Q/A and get answers there. It also has the advantage that you can go back and look at the answers later. The Q/A page can be found here: https://umeauniversity.sharepoint.com/:w:/s/HPC2N630/IQCI0r5NQ-gWQJI4oBi6trbXAWlznFWAQaBab_i5erb9VME?e=HyfiWp","title":"Important info"},{"location":"#preliminary__schedule","text":"Time Topic Activity Teacher 9:00 Welcome+Syllabus Joachim 9:10 What is Linux? Why should you use it? Lecture Joachim 9:20 The command line (CLI) Lecture+code along Sahar 9:30 Navigating the File System Lecture+code along+exercise Sahar 10:00 Modifying the file tree Lecture+code along+exercise Sahar 10:25 BREAK 10:40 Editors Lecture+code along Pedro 10:50 Piping and filters Lecture+code along+exercise Pedro 11:10 Finding patterns Lecture+code along+exercises Pedro 11:25 Scripting Lecture+code along Pedro 11:40 Hints and tricks Lecture+code along Joachim 11:50 Summary Joachim 12:00 END of course","title":"Preliminary schedule"},{"location":"#preparations","text":"In order to type along and do the exercises, please prepare your course environment now: Login to the system you are using (Tetralith, your own computer, other system) Create a directory to work in ( mkdir intro-linux ) and then switch to it ( cd intro-linux ) NOTE If you are working on Tetralith, first switch to your working directory: cd /proj/spring-courses-naiss/users/YOUR-USERNAME Download the exercises with wget https://github.com/hpc2n/linux-command-line-101/raw/refs/heads/main/exercises.tar.gz Check the contents of the file tar tzvf exercises.tar.gz Extract the exercises with tar xzvf exercises.tar.gz Enter the directory that was created: cd exercises Remark: By default the utility wget is not installed on a Mac. You can download from the website: https://github.com/hpc2n/linux-command-line-101/blob/main/exercises.tar.gz and move the file: mv ~/Downloads/exercises.tar.gz . instead of step 3.","title":"Preparations"},{"location":"cheat/","text":"Linux Cheat Sheet \u00b6 written by P. Ojeda with minor updates/changes by B. Bryds\u00f8. Miscellaneous Command Effect \u2502 Command Effect ls List files in current directory \u2502 less FILE See the content of file FILE ls -lah List files in human readable format \u2502 vim FILE Edit FILE with vim cd /dir Change to the directory \u201cdir\u201d \u2502 whereis data Prints out the location of \u201cdata\u201d pwd Your current PATH \u2502 tar -cvzf file.tgz FILE Pack and compress \u201cFILE\u201d rm FILE Delete FILE \u2502 gunzip file.tgz Uncompress \u201cfile.tgz\u201d rm -rf DIR Delete directory DIR \u2502 tar -xvf file.tar Unpack \u201cfile.tar\u201d Wildcards Wildcard Meaning * Means zero or any number of characters. Ex. File* could be File, File2, Fileuiwie, \u2026 ? Means only one character. Ex. File? could be File1, Filex, Fileh, but not File22 [] Means a range of characters. Ex. File[1-3] could be File1, File2, File3 grep Command Meaning grep \u2018word\u2019 file Search for the pattern \u2018word\u2019 in \u2018file\u2019 grep -rine \u2018word\u2019 home Search for the pattern \u2018word\u2019 recursively in the directory /home find Command Meaning find /home -name \u2018*.dat\u2019 Find the files in the directory home ending in \u2018.dat\u2019 find /home -mtime +60 Find every file in /home that was modified more than 60 days ago pipes Command Meaning | Take the output of one command as the input of another. Ex. ls Secure copy protocol Command Effect scp file user123@kebnekaise.hpc2n.umu.se:/home/u/user123/ Copy \u201cfile\u201d to the home directory of the user \u201cuser123\u201d Note: vim commands are in ESC mode Bash shortcuts Meaning \u2502 vim commands Meaning ctrl+r Make a reverse search \u2502 :w file.txt Save file.txt ctrl+a Go to the beginning of the line \u2502 :q! Exit without saving ctrl+e Go to the end of the line \u2502 :%s/pat1/pat2/g Replace pattern \u201cpat1\u201d by \u201cpat2\u201d ctrl+w Delete the previous word \u2502 ctrl+v Start selection ctrl+k Delete words after cursor \u2502 dd Delete line ctrl+u Delete current line \u2502 x Delete character ctrl+l Clean terminal \u2502 r Replace character awk Command Meaning awk \u2018/gold/ {print $1}\u2019 coins.txt Search for pattern \u201cgold\u201d in the file coins.txt and print first column Batch jobs Command Effect sbatch job.sh Launch \u201cjob.sh\u201d to the queue squeue -u user123 Check the jobs from the user \u201cuser123\u201d scancel JOBID Remove the job with id \u201cJOBID\u201d from the queue squeue -f JOBID Check the details about the job with id \u201cJOBID\u201d sshfs Command Meaning sshfs user123@kebnekaise.hpc2n.umu.se /dir1/ /local/dir2 Mount /dir1 (on Quarry) into your /local/dir2 fusermount -u /local/dir2 Unmount the /local/dir2","title":"Linux cheat sheet"},{"location":"cheat/#linux__cheat__sheet","text":"written by P. Ojeda with minor updates/changes by B. Bryds\u00f8. Miscellaneous Command Effect \u2502 Command Effect ls List files in current directory \u2502 less FILE See the content of file FILE ls -lah List files in human readable format \u2502 vim FILE Edit FILE with vim cd /dir Change to the directory \u201cdir\u201d \u2502 whereis data Prints out the location of \u201cdata\u201d pwd Your current PATH \u2502 tar -cvzf file.tgz FILE Pack and compress \u201cFILE\u201d rm FILE Delete FILE \u2502 gunzip file.tgz Uncompress \u201cfile.tgz\u201d rm -rf DIR Delete directory DIR \u2502 tar -xvf file.tar Unpack \u201cfile.tar\u201d Wildcards Wildcard Meaning * Means zero or any number of characters. Ex. File* could be File, File2, Fileuiwie, \u2026 ? Means only one character. Ex. File? could be File1, Filex, Fileh, but not File22 [] Means a range of characters. Ex. File[1-3] could be File1, File2, File3 grep Command Meaning grep \u2018word\u2019 file Search for the pattern \u2018word\u2019 in \u2018file\u2019 grep -rine \u2018word\u2019 home Search for the pattern \u2018word\u2019 recursively in the directory /home find Command Meaning find /home -name \u2018*.dat\u2019 Find the files in the directory home ending in \u2018.dat\u2019 find /home -mtime +60 Find every file in /home that was modified more than 60 days ago pipes Command Meaning | Take the output of one command as the input of another. Ex. ls Secure copy protocol Command Effect scp file user123@kebnekaise.hpc2n.umu.se:/home/u/user123/ Copy \u201cfile\u201d to the home directory of the user \u201cuser123\u201d Note: vim commands are in ESC mode Bash shortcuts Meaning \u2502 vim commands Meaning ctrl+r Make a reverse search \u2502 :w file.txt Save file.txt ctrl+a Go to the beginning of the line \u2502 :q! Exit without saving ctrl+e Go to the end of the line \u2502 :%s/pat1/pat2/g Replace pattern \u201cpat1\u201d by \u201cpat2\u201d ctrl+w Delete the previous word \u2502 ctrl+v Start selection ctrl+k Delete words after cursor \u2502 dd Delete line ctrl+u Delete current line \u2502 x Delete character ctrl+l Clean terminal \u2502 r Replace character awk Command Meaning awk \u2018/gold/ {print $1}\u2019 coins.txt Search for pattern \u201cgold\u201d in the file coins.txt and print first column Batch jobs Command Effect sbatch job.sh Launch \u201cjob.sh\u201d to the queue squeue -u user123 Check the jobs from the user \u201cuser123\u201d scancel JOBID Remove the job with id \u201cJOBID\u201d from the queue squeue -f JOBID Check the details about the job with id \u201cJOBID\u201d sshfs Command Meaning sshfs user123@kebnekaise.hpc2n.umu.se /dir1/ /local/dir2 Mount /dir1 (on Quarry) into your /local/dir2 fusermount -u /local/dir2 Unmount the /local/dir2","title":"Linux Cheat Sheet"},{"location":"cli/","text":"The command line interface and the shell \u00b6 Learning objectives Questions What is a Command Line Interface (CLI)? What is a shell? Why/when should I use it? Objectives You will learn about the shell and the CLI. You will learn why and when you should use a CLI instead of a Graphical User Interface (GUI). The picture above shows a terminal window where a user is logged into NAISS\u2019s Tetralith system. Inside the terminal there is a shell running. One can see the prompt waiting for user input. This is an example of a command line interface (CLI). It allows a user to interact with the computer system by typing in commands directly. It is a user interface that is navigated with only a keyboard, instead of by clicking with a mouse or using a touchscreen. A commandline interface is currently available in all major operating systems, including Windows, UNIX, Linux, and macOS. Note In Unix or Linux, the prompt may be shown as $ , % , # , or > depending on the shell used and the system\u2019s set-up. In addition it may show details such as the user name, the name of the system, or the position in the directory tree. The position in the file tree is commonly referred to as the PATH . The prompt means the shell is waiting for input from you. A common alternative to a CLI is a GUI (Graphical User Interface), which typically uses a mouse or similar for navigating. While a GUI is often more intuitive for a new user, the CLI is more powerful. Command line interfaces often give access to more capabilities than graphical user interfaces do. Many repetive tasks, which can be tedious in a GUI, can be easily automated in a shell with a CLI. Shell \u00b6 As mentioned in the intro, the shell is an interface between the keyboard and the computer\u2019s operating system (OS), i.e., it takes input from the user via the keyboard and sends it to the OS, which then performs the actions requested. In this course we will focus on the Bash ( B ourne A gain SH ell). There are many alternatives and the commands can look quite different when using another shell than Bash. Bash is both a command-line interpreter providing a Command Line Interface (CLI) and a scripting language. Writing scripts in a shell allows you to automate repetitive tasks or combine several tasks, making your workflow faster and more efficient. For example, if you want to iterate over many files, this can be done easily in the shell. Warning You will find that many/most commands in this course are prefaced with either $ or [user@tetralith1 ~] , or something like [user@tetralith1 us]$ . This is the prompt from the computer system, where $ just is the default ( bash ) prompt, and the others are examples of a prompt you may see when logged into a compute cluster (in this case Tetralith - home directory versus a project storage directory). You can see an example of such a prompt in the picture a bit further up on the page, when a user with the user-id x_joahe is connected to NAISS\u2019s Tetralith system. IMPORTANT Do NOT copy the prompt if you are copying code snippets. It should not be included in the command. Terminology \u00b6 You may hear words such as shell, terminal, console, and command line interface. So what are the differences? Are they the interchangeable? Short answer: terminal = text input/output environment console = physical terminal shell = command line interpreter Slightly longer answer (CLICK to read) Console and terminal both originally referred to a device similar to a typewriter which was used to interact with the computer. It was sometimes called a teletypewriter (tty) or teleprinter. A terminal in Linux/Unix terminology is a device file (interface to a device driver) which implements some commands (read, write, and some more). Some terminal emulators (a.k.a. terminal applications): Xterm, Gnome terminal, Konsole, SSH, \u2026 A console is generally a terminal in the physical sense, i.e., often the primary terminal directly connected to a machine. On Linux the console appears as several terminals that can be switched between, and each of these can be named console, virtual console, virtual terminal, etc. A Command Line Interface (CLI) is an interface where the user types a command and then presses RETURN/ENTER to execute the command. A shell is the main interface seen by the user when they login. It is used to start other programs. It is a command-line shell, and there are many different ones, as mentioned earlier. Command-line shells include flow control constructs to combine commands. In addition to typing commands at an interactive prompt, users can write scripts. Try it out \u00b6 Exercise: Open a terminal Do one of the following: Open a terminal on Tetralith. Use an SSH client of your choice or ThinLinc . The server name is the same for both interfaces (at most HPC centres, the server name varies slightly between these interfaces). Log in with your USERNAME: ssh USERNAME@tetralith.nsc.liu.se If you logged in with ThinLinc, open a terminal. Open a terminal on any other HPC system where you have an account. Open a terminal on your own computer. Code-along: try a few commands NOTE: These commands will all be described in more depth in the next section on Navigating the File System List some files and directories: ls Create a file (name it anything - MYFILE.txt is just a placeholder): touch MYFILE.txt Create a directory (name it anything you want - MYDIR is just a placeholder): mkdir MYDIR List your files and directories again: ls Error messages \u00b6 Error messages If you mistype a command, or the program/script is not available, you will get an error message like the following (on Tetralith where username is x_birbr ): [ x_birbr@tetralith3 ~ ] $ ks -bash: ks: command not found [ x_birbr@tetralith3 ~ ] $ it may look a little different depending on the system (e.g., on defiant where username is bbrydsoe ): bbrydsoe@defiant:~$ ks ks: command not found bbrydsoe@defiant:~$ If you instead execute a command on a file which is not available (or not accessible, due to permissions ), it will look something like this (you can also use ls to list a specific file): [ x_birbr@tetralith3 ~ ] $ ls myfile.c ls: cannot access 'myfile.c' : No such file or directory [ x_birbr@tetralith3 ~ ] $ If you do not have permission to open or modify a file, the error message will include the phrase Permission denied . Keypoints A shell is a special user program. It is an interface between the keyboard and the operating system that takes input from the user and sends it to the OS, which then performs the actions requested. We will use bash in this course. You can run programs from the shell by entering commands at the command-line interface, or CLI. There are many advantages to using the shell, particularly the ability to automate repetitive tasks and combine smaller tasks in a script, as well as the speed of executing commands compared with the more resource-intensive GUI. The shell is also easier to use remotely. A difficulty with the shell can be finding out which commands exist and how to run them.","title":"The command line (CLI)"},{"location":"cli/#the__command__line__interface__and__the__shell","text":"Learning objectives Questions What is a Command Line Interface (CLI)? What is a shell? Why/when should I use it? Objectives You will learn about the shell and the CLI. You will learn why and when you should use a CLI instead of a Graphical User Interface (GUI). The picture above shows a terminal window where a user is logged into NAISS\u2019s Tetralith system. Inside the terminal there is a shell running. One can see the prompt waiting for user input. This is an example of a command line interface (CLI). It allows a user to interact with the computer system by typing in commands directly. It is a user interface that is navigated with only a keyboard, instead of by clicking with a mouse or using a touchscreen. A commandline interface is currently available in all major operating systems, including Windows, UNIX, Linux, and macOS. Note In Unix or Linux, the prompt may be shown as $ , % , # , or > depending on the shell used and the system\u2019s set-up. In addition it may show details such as the user name, the name of the system, or the position in the directory tree. The position in the file tree is commonly referred to as the PATH . The prompt means the shell is waiting for input from you. A common alternative to a CLI is a GUI (Graphical User Interface), which typically uses a mouse or similar for navigating. While a GUI is often more intuitive for a new user, the CLI is more powerful. Command line interfaces often give access to more capabilities than graphical user interfaces do. Many repetive tasks, which can be tedious in a GUI, can be easily automated in a shell with a CLI.","title":"The command line interface and the shell"},{"location":"cli/#shell","text":"As mentioned in the intro, the shell is an interface between the keyboard and the computer\u2019s operating system (OS), i.e., it takes input from the user via the keyboard and sends it to the OS, which then performs the actions requested. In this course we will focus on the Bash ( B ourne A gain SH ell). There are many alternatives and the commands can look quite different when using another shell than Bash. Bash is both a command-line interpreter providing a Command Line Interface (CLI) and a scripting language. Writing scripts in a shell allows you to automate repetitive tasks or combine several tasks, making your workflow faster and more efficient. For example, if you want to iterate over many files, this can be done easily in the shell. Warning You will find that many/most commands in this course are prefaced with either $ or [user@tetralith1 ~] , or something like [user@tetralith1 us]$ . This is the prompt from the computer system, where $ just is the default ( bash ) prompt, and the others are examples of a prompt you may see when logged into a compute cluster (in this case Tetralith - home directory versus a project storage directory). You can see an example of such a prompt in the picture a bit further up on the page, when a user with the user-id x_joahe is connected to NAISS\u2019s Tetralith system. IMPORTANT Do NOT copy the prompt if you are copying code snippets. It should not be included in the command.","title":"Shell"},{"location":"cli/#terminology","text":"You may hear words such as shell, terminal, console, and command line interface. So what are the differences? Are they the interchangeable? Short answer: terminal = text input/output environment console = physical terminal shell = command line interpreter Slightly longer answer (CLICK to read) Console and terminal both originally referred to a device similar to a typewriter which was used to interact with the computer. It was sometimes called a teletypewriter (tty) or teleprinter. A terminal in Linux/Unix terminology is a device file (interface to a device driver) which implements some commands (read, write, and some more). Some terminal emulators (a.k.a. terminal applications): Xterm, Gnome terminal, Konsole, SSH, \u2026 A console is generally a terminal in the physical sense, i.e., often the primary terminal directly connected to a machine. On Linux the console appears as several terminals that can be switched between, and each of these can be named console, virtual console, virtual terminal, etc. A Command Line Interface (CLI) is an interface where the user types a command and then presses RETURN/ENTER to execute the command. A shell is the main interface seen by the user when they login. It is used to start other programs. It is a command-line shell, and there are many different ones, as mentioned earlier. Command-line shells include flow control constructs to combine commands. In addition to typing commands at an interactive prompt, users can write scripts.","title":"Terminology"},{"location":"cli/#try__it__out","text":"Exercise: Open a terminal Do one of the following: Open a terminal on Tetralith. Use an SSH client of your choice or ThinLinc . The server name is the same for both interfaces (at most HPC centres, the server name varies slightly between these interfaces). Log in with your USERNAME: ssh USERNAME@tetralith.nsc.liu.se If you logged in with ThinLinc, open a terminal. Open a terminal on any other HPC system where you have an account. Open a terminal on your own computer. Code-along: try a few commands NOTE: These commands will all be described in more depth in the next section on Navigating the File System List some files and directories: ls Create a file (name it anything - MYFILE.txt is just a placeholder): touch MYFILE.txt Create a directory (name it anything you want - MYDIR is just a placeholder): mkdir MYDIR List your files and directories again: ls","title":"Try it out"},{"location":"cli/#error__messages","text":"Error messages If you mistype a command, or the program/script is not available, you will get an error message like the following (on Tetralith where username is x_birbr ): [ x_birbr@tetralith3 ~ ] $ ks -bash: ks: command not found [ x_birbr@tetralith3 ~ ] $ it may look a little different depending on the system (e.g., on defiant where username is bbrydsoe ): bbrydsoe@defiant:~$ ks ks: command not found bbrydsoe@defiant:~$ If you instead execute a command on a file which is not available (or not accessible, due to permissions ), it will look something like this (you can also use ls to list a specific file): [ x_birbr@tetralith3 ~ ] $ ls myfile.c ls: cannot access 'myfile.c' : No such file or directory [ x_birbr@tetralith3 ~ ] $ If you do not have permission to open or modify a file, the error message will include the phrase Permission denied . Keypoints A shell is a special user program. It is an interface between the keyboard and the operating system that takes input from the user and sends it to the OS, which then performs the actions requested. We will use bash in this course. You can run programs from the shell by entering commands at the command-line interface, or CLI. There are many advantages to using the shell, particularly the ability to automate repetitive tasks and combine smaller tasks in a script, as well as the speed of executing commands compared with the more resource-intensive GUI. The shell is also easier to use remotely. A difficulty with the shell can be finding out which commands exist and how to run them.","title":"Error messages"},{"location":"connections/","text":"Overview of Linux system \u00b6 This is a brief overview of how the parts of a Linux system go together: To read more about the terms, go to the Linux terminology section under \u201cEXTRAS\u201d.","title":"Linux system overview"},{"location":"connections/#overview__of__linux__system","text":"This is a brief overview of how the parts of a Linux system go together: To read more about the terms, go to the Linux terminology section under \u201cEXTRAS\u201d.","title":"Overview of Linux system"},{"location":"data/","text":"Data Handling \u00b6 This section will briefly cover compressing/decompressing files/directories, transferring files, and logging in. Objectives Questions How do I compress and decompress files and directories under Linux? How do I create an archive (tarball)? How do I transfer and sync files? How do I connect with SSH? Learning objectives Learn about compressing and decompressing files and directories with gzip Learn about archiving (creating a tarball) with tar Learn about transferring and syncing files Learn about connectin gwith SSH Compressing and decompressing \u00b6 Compressing files are done with utilities like gzip , bzip2 , or zip . Compressing a file with gzip gzip FILE This results in FILE.gz Decompressing a file with gzip gunzip FILE.gz You now again have FILE Archiving \u00b6 Archiving is generally done with tar . A tarball is a commonly used name to refer to an archive file in the tar (Tape Archive) format. A tarball can be compressed with something like gzip or bzip2. tar [ -options ] <name of the tar archive> [ files or directories which to add into archive ] Basic options: -c, --create \u2014 create a new archive ; -a, --auto-compress \u2014 additionally compress the archive with a compressor which will be automatically determined by the file name extension of the archive. If the archive 's name ends with *.tar.gz then use gzip, if *.tar.xz then use xz, *.tar.zst for Zstandard etc.; -r, --append \u2014 append files to the end of an archive; -x, --extract, --get \u2014 extract files from an archive; -f, --file \u2014 specify the archive' s name ; -t, --list \u2014 show a list of files and folders in the archive ; -v, --verbose \u2014 show a list of processed files. Hint Code-along! You can either download the tarball temp.tar.gz to play with (right-click and save): temp.tar.gz or use the exercises.tar.gz tarball. Here follows some examples: Generate a tarball tar -cvf DIRECTORY.tar DIRECTORY Extracting the files from a tarball tar -xvf DIRECTORY.tar Generate a tarball and compress it with gzip tar -zcvf DIRECTORY.tar.gz DIRECTORY Uncompressing and extracting files from a tarball tar -zxvf DIRECTORY.tar.gz More information can be found in HPC2N\u2019s documentation\u2019s Archiving and compressing section . File transfer and syncing \u00b6 There are several possible ways to transfer files and data to and from Linux systems: scp, sftp, rsync\u2026 Warning FTP is generally not permitted due to security problems! SCP \u00b6 SCP (Secure CoPy) is a simple way of transferring files between two machines that use the SSH (Secure SHell) protocol. From local system to a remote system $ scp sourcefilename user@hostname:somedir/destfilename From a remote system to a local system $ scp user@hostname:somedir/sourcefilename destfilename SFTP \u00b6 SFTP (SSH File Transfer Protocol or sometimes called Secure File Transfer Protocol) is a network protocol that provides file transfer over a reliable data stream. From a local system to a remote system This example was made with the remote system \u201cKebnekaise\u201d belonging to HPC2N. enterprise-d [ ~ ] $ sftp user@kebnekaise.hpc2n.umu.se Connecting to kebnekaise.hpc2n.umu.se... user@kebnekaise.hpc2n.umu.se ' s password: sftp> put file.c C/file.c Uploading file.c to /home/u/user/C/file.c file.c 100 % 1 0 .0KB/s 00 :00 sftp> put -P irf.png pic/ Uploading irf.png to /home/u/user/pic/irf.png irf.png 100 % 2100 2 .1KB/s 00 :00 sftp> From a remote system to a local system sftp> get file2.c C/file2.c Fetching /home/u/user/file2.c to C/file2.c /home/u/user/file.txt 100 % 1 0 .1KB/s 00 :00 sftp> get -P file3.c C/ Fetching /home/u/user/file3.c to C/file3.c /home/u/user/file.txt 100 % 1 0 .4KB/s 00 :00 sftp> exit enterprise-d [ ~ ] $ rsync \u00b6 rsync is a utility for efficiently transferring and synchronizing files between a computer and a storage drive and across networked computers by comparing the modification times and sizes of files. Recursively sync files from one remote directory to a local directory. Also preserve symbolic links and time stamps, and allows resume of partially transferred files on restart rsync -rlpt username@remote_host:sourcedir/ /path/to/localdir Recursively sync a local directory to a remote destination directory, preserving owners, permission, modification times, and symbolic links rsync -a /path/to/localdir/ username@remote_host:destination_directory Much more information and examples can be found in the HPC2N documentation\u2019s File transfer section . Connecting with ssh \u00b6 The ssh command is used for connecting to a remote computer. Some useful examples: Connecting to a compute cluster called Kebnekaise ssh username@kebnekaise.hpc2n.umu.se Connecting to Kebnekaise and enabling graphical display ssh -Y username@kebnekaise.hpc2n.umu.se Note that you need to have an X11 server like Xming or Cygwin on Windows, XQuartz on macOS (included on Linux) to open a graphical display. Tip If you are using a graphical display, then we are strongly recommending ThinLinc. There is information about connecting with ThinLinc at most Swedish HPC centres. Here is the information from HPC2N . Keypoints Files and directories can be compressed with zip , gzip and other programs on Linux Creating a \u201ctarball\u201d with tar is often very useful, since this means you can transfer just one file instead of many. It can be combined with compressing. sftp and rsync are useful for transferring and syncing your files between different computers SSH is a way to connect to a remote computer from the command line","title":"Data handling"},{"location":"data/#data__handling","text":"This section will briefly cover compressing/decompressing files/directories, transferring files, and logging in. Objectives Questions How do I compress and decompress files and directories under Linux? How do I create an archive (tarball)? How do I transfer and sync files? How do I connect with SSH? Learning objectives Learn about compressing and decompressing files and directories with gzip Learn about archiving (creating a tarball) with tar Learn about transferring and syncing files Learn about connectin gwith SSH","title":"Data Handling"},{"location":"data/#compressing__and__decompressing","text":"Compressing files are done with utilities like gzip , bzip2 , or zip . Compressing a file with gzip gzip FILE This results in FILE.gz Decompressing a file with gzip gunzip FILE.gz You now again have FILE","title":"Compressing and decompressing"},{"location":"data/#archiving","text":"Archiving is generally done with tar . A tarball is a commonly used name to refer to an archive file in the tar (Tape Archive) format. A tarball can be compressed with something like gzip or bzip2. tar [ -options ] <name of the tar archive> [ files or directories which to add into archive ] Basic options: -c, --create \u2014 create a new archive ; -a, --auto-compress \u2014 additionally compress the archive with a compressor which will be automatically determined by the file name extension of the archive. If the archive 's name ends with *.tar.gz then use gzip, if *.tar.xz then use xz, *.tar.zst for Zstandard etc.; -r, --append \u2014 append files to the end of an archive; -x, --extract, --get \u2014 extract files from an archive; -f, --file \u2014 specify the archive' s name ; -t, --list \u2014 show a list of files and folders in the archive ; -v, --verbose \u2014 show a list of processed files. Hint Code-along! You can either download the tarball temp.tar.gz to play with (right-click and save): temp.tar.gz or use the exercises.tar.gz tarball. Here follows some examples: Generate a tarball tar -cvf DIRECTORY.tar DIRECTORY Extracting the files from a tarball tar -xvf DIRECTORY.tar Generate a tarball and compress it with gzip tar -zcvf DIRECTORY.tar.gz DIRECTORY Uncompressing and extracting files from a tarball tar -zxvf DIRECTORY.tar.gz More information can be found in HPC2N\u2019s documentation\u2019s Archiving and compressing section .","title":"Archiving"},{"location":"data/#file__transfer__and__syncing","text":"There are several possible ways to transfer files and data to and from Linux systems: scp, sftp, rsync\u2026 Warning FTP is generally not permitted due to security problems!","title":"File transfer and syncing"},{"location":"data/#scp","text":"SCP (Secure CoPy) is a simple way of transferring files between two machines that use the SSH (Secure SHell) protocol. From local system to a remote system $ scp sourcefilename user@hostname:somedir/destfilename From a remote system to a local system $ scp user@hostname:somedir/sourcefilename destfilename","title":"SCP"},{"location":"data/#sftp","text":"SFTP (SSH File Transfer Protocol or sometimes called Secure File Transfer Protocol) is a network protocol that provides file transfer over a reliable data stream. From a local system to a remote system This example was made with the remote system \u201cKebnekaise\u201d belonging to HPC2N. enterprise-d [ ~ ] $ sftp user@kebnekaise.hpc2n.umu.se Connecting to kebnekaise.hpc2n.umu.se... user@kebnekaise.hpc2n.umu.se ' s password: sftp> put file.c C/file.c Uploading file.c to /home/u/user/C/file.c file.c 100 % 1 0 .0KB/s 00 :00 sftp> put -P irf.png pic/ Uploading irf.png to /home/u/user/pic/irf.png irf.png 100 % 2100 2 .1KB/s 00 :00 sftp> From a remote system to a local system sftp> get file2.c C/file2.c Fetching /home/u/user/file2.c to C/file2.c /home/u/user/file.txt 100 % 1 0 .1KB/s 00 :00 sftp> get -P file3.c C/ Fetching /home/u/user/file3.c to C/file3.c /home/u/user/file.txt 100 % 1 0 .4KB/s 00 :00 sftp> exit enterprise-d [ ~ ] $","title":"SFTP"},{"location":"data/#rsync","text":"rsync is a utility for efficiently transferring and synchronizing files between a computer and a storage drive and across networked computers by comparing the modification times and sizes of files. Recursively sync files from one remote directory to a local directory. Also preserve symbolic links and time stamps, and allows resume of partially transferred files on restart rsync -rlpt username@remote_host:sourcedir/ /path/to/localdir Recursively sync a local directory to a remote destination directory, preserving owners, permission, modification times, and symbolic links rsync -a /path/to/localdir/ username@remote_host:destination_directory Much more information and examples can be found in the HPC2N documentation\u2019s File transfer section .","title":"rsync"},{"location":"data/#connecting__with__ssh","text":"The ssh command is used for connecting to a remote computer. Some useful examples: Connecting to a compute cluster called Kebnekaise ssh username@kebnekaise.hpc2n.umu.se Connecting to Kebnekaise and enabling graphical display ssh -Y username@kebnekaise.hpc2n.umu.se Note that you need to have an X11 server like Xming or Cygwin on Windows, XQuartz on macOS (included on Linux) to open a graphical display. Tip If you are using a graphical display, then we are strongly recommending ThinLinc. There is information about connecting with ThinLinc at most Swedish HPC centres. Here is the information from HPC2N . Keypoints Files and directories can be compressed with zip , gzip and other programs on Linux Creating a \u201ctarball\u201d with tar is often very useful, since this means you can transfer just one file instead of many. It can be combined with compressing. sftp and rsync are useful for transferring and syncing your files between different computers SSH is a way to connect to a remote computer from the command line","title":"Connecting with ssh"},{"location":"editors/","text":"Editors \u00b6 Learning objectives Questions Which editors are good to use on the command line? Which editors are good for using in a GUI (graphical user interface) environment? Objectives Learn about some command line editors Try and use nano Learn about some GUI editors Try use gedit Some editors are more suited for a GUI environment and some are more suited for a command line environment. less, more, cat \u00b6 less, more, cat - if you just need to see the content If you just need to see the content of a file, these commands are probably the best, since there is no risk of you making changes to the file if you are just looking in it. more: forward navigation and limited backward navigation in a file named FILE. Usage: more FILE Exit with: q less: forward and backward navigation and also has search options. Usage less FILE Exit with: q cat: a tool for file-related operations (view, concatenate, create, copy, merge, and manipulate file contents). Usage: cat [option] FILE where option is various optional options (hint: man cat for more info). Reminder If you are just looking in a file, do not use an editor (nano, vim, emacs, \u2026) as you risk making changes if, for instance, your cat runs across the keyboard! Use something like cat or less instead. Try out less and cat ! Go to the exercises/mytestdir directory (that you got from the tarball at the beginning of the course). Use less on the file myfile.txt . Use cat on the same file. Question : Why is cat good for short files, but not for long files? Command line editors \u00b6 These are all good editors available on the command line: nano vi , vim emacs Of these, vi/vim as well as emacs are probably the most powerful, though the latter is better in a GUI environment. The easiest editor to use if you are not familiar with any of them is nano . Nano HINT: code-along! Starting nano : Type nano FILENAME on the command line and press Enter . FILENAME is whatever you want to call your file. If FILENAME is a file that already exists, nano will open the file. If it dows not exist, it will be created. You now get an editor that looks like this: First thing to notice is that many of the commands are listed at the bottom. The ^ before the letter-commands means you should press CTRL and then the letter (while keeping CTRL down). Your prompt is in the editor window itself, and you can just type (or copy and paste) the content you want in your file. When you want to exit (and possibly save), you press CTRL and then x while holding CTRL down (this is written CTRL-x or ^x). nano will ask you if you want to save the content of the buffer to the file. After that it will exit. There is a manual for nano here . GUI editors \u00b6 If you are connecting with ThinLinc , you will be presented with a graphical user interface (GUI). (For Tetralith, the server is tetralith.nsc.liu.se ). From within Thinlinc you can either open a terminal window/shell or you can choose editors from the menu. It differs a bit how Thinlinc looks depending on the centre, and it also differs which desktop environment they are running. For instance, NSC\u2019s Tetralith has the Xfce environment while HPC2N\u2019s Kebnekaise has MATE. Examples to open terminal: HPC2N: \u201cApplications\u201d -> \u201cSystem Tools\u201d -> \u201cMATE Terminal\u201d NSC: \u201cApplications\u201d -> \u201cSystem\u201d -> \u201cXfce Terminal\u201d To choose editors from the menu: HPC2N: \u201cApplications -> Accessories\u201d. NSC: \u201cApplications\u201d -> Accessories\u201d -> \u201cApplications\u201d or \u201cDevelopment\u201d -> Several choices: \u201cGvim\u201d, \u201cEmacs\u201d, \u201cNedit\u201d, \u2026 Regardless, this gives several editor options, of which these have a graphical interface: HPC2N/NSC: Text Editor (gedit) HPC2N: Pluma - the default editor on the MATE desktop environments (that Thinlinc runs) HPC2N: Atom - no t just an editor, but an IDE HPC2N/NSC: Emacs (GUI) HPC2N/NSC (under \u201cApplications\u201d -> \u201cDevelopment\u201d): NEdit \u201cNirvana Text Editor\u201d If you are not familiar with any of these, a good recommendation would be to use Text Editor: gedit . Text Editor: gedit Starting \u201cgedit\u201d: From the menu, choose Applications -> Accessories -> Text Editor. You then get a window that looks similar to this: You can open files by clicking \u201cOpen\u201d in the top menu. Clicking the small file icon with a plus (located beside the \u201cOpen\u201d button\u201d) will create a new document. Save by clicking \u201cSave\u201d in the menu. The menu on the top right (the three horizontal lines) gives you several other options, including \u201cFind\u201d and \u201cFind and Replace\u201d. Keypoints If you just want to look in a file, it is better to use less , more , or cat Some editors are best for the command line and some are best for a GUI environment nano is a good first editor for the command line other editors for the command line are: vi / vim , emacs , etc. gedit (Text editor) is a good first editor for the GUI other editors for a GUI environment are: Pluma , Atom , emacs (GUI) , NEdit , etc.","title":"Editors"},{"location":"editors/#editors","text":"Learning objectives Questions Which editors are good to use on the command line? Which editors are good for using in a GUI (graphical user interface) environment? Objectives Learn about some command line editors Try and use nano Learn about some GUI editors Try use gedit Some editors are more suited for a GUI environment and some are more suited for a command line environment.","title":"Editors"},{"location":"editors/#less__more__cat","text":"less, more, cat - if you just need to see the content If you just need to see the content of a file, these commands are probably the best, since there is no risk of you making changes to the file if you are just looking in it. more: forward navigation and limited backward navigation in a file named FILE. Usage: more FILE Exit with: q less: forward and backward navigation and also has search options. Usage less FILE Exit with: q cat: a tool for file-related operations (view, concatenate, create, copy, merge, and manipulate file contents). Usage: cat [option] FILE where option is various optional options (hint: man cat for more info). Reminder If you are just looking in a file, do not use an editor (nano, vim, emacs, \u2026) as you risk making changes if, for instance, your cat runs across the keyboard! Use something like cat or less instead. Try out less and cat ! Go to the exercises/mytestdir directory (that you got from the tarball at the beginning of the course). Use less on the file myfile.txt . Use cat on the same file. Question : Why is cat good for short files, but not for long files?","title":"less, more, cat"},{"location":"editors/#command__line__editors","text":"These are all good editors available on the command line: nano vi , vim emacs Of these, vi/vim as well as emacs are probably the most powerful, though the latter is better in a GUI environment. The easiest editor to use if you are not familiar with any of them is nano . Nano HINT: code-along! Starting nano : Type nano FILENAME on the command line and press Enter . FILENAME is whatever you want to call your file. If FILENAME is a file that already exists, nano will open the file. If it dows not exist, it will be created. You now get an editor that looks like this: First thing to notice is that many of the commands are listed at the bottom. The ^ before the letter-commands means you should press CTRL and then the letter (while keeping CTRL down). Your prompt is in the editor window itself, and you can just type (or copy and paste) the content you want in your file. When you want to exit (and possibly save), you press CTRL and then x while holding CTRL down (this is written CTRL-x or ^x). nano will ask you if you want to save the content of the buffer to the file. After that it will exit. There is a manual for nano here .","title":"Command line editors"},{"location":"editors/#gui__editors","text":"If you are connecting with ThinLinc , you will be presented with a graphical user interface (GUI). (For Tetralith, the server is tetralith.nsc.liu.se ). From within Thinlinc you can either open a terminal window/shell or you can choose editors from the menu. It differs a bit how Thinlinc looks depending on the centre, and it also differs which desktop environment they are running. For instance, NSC\u2019s Tetralith has the Xfce environment while HPC2N\u2019s Kebnekaise has MATE. Examples to open terminal: HPC2N: \u201cApplications\u201d -> \u201cSystem Tools\u201d -> \u201cMATE Terminal\u201d NSC: \u201cApplications\u201d -> \u201cSystem\u201d -> \u201cXfce Terminal\u201d To choose editors from the menu: HPC2N: \u201cApplications -> Accessories\u201d. NSC: \u201cApplications\u201d -> Accessories\u201d -> \u201cApplications\u201d or \u201cDevelopment\u201d -> Several choices: \u201cGvim\u201d, \u201cEmacs\u201d, \u201cNedit\u201d, \u2026 Regardless, this gives several editor options, of which these have a graphical interface: HPC2N/NSC: Text Editor (gedit) HPC2N: Pluma - the default editor on the MATE desktop environments (that Thinlinc runs) HPC2N: Atom - no t just an editor, but an IDE HPC2N/NSC: Emacs (GUI) HPC2N/NSC (under \u201cApplications\u201d -> \u201cDevelopment\u201d): NEdit \u201cNirvana Text Editor\u201d If you are not familiar with any of these, a good recommendation would be to use Text Editor: gedit . Text Editor: gedit Starting \u201cgedit\u201d: From the menu, choose Applications -> Accessories -> Text Editor. You then get a window that looks similar to this: You can open files by clicking \u201cOpen\u201d in the top menu. Clicking the small file icon with a plus (located beside the \u201cOpen\u201d button\u201d) will create a new document. Save by clicking \u201cSave\u201d in the menu. The menu on the top right (the three horizontal lines) gives you several other options, including \u201cFind\u201d and \u201cFind and Replace\u201d. Keypoints If you just want to look in a file, it is better to use less , more , or cat Some editors are best for the command line and some are best for a GUI environment nano is a good first editor for the command line other editors for the command line are: vi / vim , emacs , etc. gedit (Text editor) is a good first editor for the GUI other editors for a GUI environment are: Pluma , Atom , emacs (GUI) , NEdit , etc.","title":"GUI editors"},{"location":"filesystem/","text":"Navigating the File System \u00b6 This section will be a basic overview of the Linux filesystem concepts, not an in-depth description of filesystem types. Learning objectives Questions How do I change directory? How do I list my files? Learning objectives Learn how to navigate the Linux file system Learn about files and directories Learn about paths Learn about options (flags) and arguments to shell commands Learn about the tab completion The Linux filesystem directory structure starts with the top root directory, which is shown as / . Below this are several other standard directories. Of particular interest are usr/bin , home , usr/lib , and usr/lib64 . A common directory which you will also often find is usr/local/bin . The picture on the right shows typical subdirectories under / (note that the command tree does not work at all HPC centers, though it does work on Tetralith\u2014see the page tree under the \u201cExtras\u201d section for how to install if it is missing). Some of the directories have a symbolic link to a different name\u2014this is often done to make it quicker to write, but can also be for compatibility reasons since some software have hardcoded paths. Note The path or pathname is the representation of the location of a file or folder/directory on a computer file system. / is the root of the directory structure on a Linux filesystem /usr/bin contains (most) of the system-specific binaries /usr/local/bin holds non-system binaries. often locally compiled/maintained packages /home is where the home directories of the users of the system are located /usr/lib holds kernel modules and shared library images needed to boot the system and run commands in the root filesystem /usr/lib64 is the same as /usr/lib , just for 64-bit libraries User installed binaries are often located in /opt . The file system could also be illustrated like this: Note about / The character / can be the root directory, if it appears alone or at the front of a file or directory name a separator if it appears in other positions within the path. Note If you are on a local cluster, on an HPC center, etc. where you are not root, you will be in your home directory by default when you login. You can use cd .. a couple times to go to the root of the system and do tree there if you want, or do tree in your home directory (you can always return there with just cd ). Caution Running tree in / on a supercomputing center will probably give a very large/long output! Home folders on Tetralith \u00b6 The above shows an illustration where the home folders are emphasized. Your home directory \u00b6 When you login to the computer (as a non root user), you will end up in your home directory. At most HPC centers, your home directory will appear as ~ in the terminal prompt, and can also be used in commands instead of having to type out /home/YOUR_USERNAME . The path to your home directory varies somewhat. Here are some examples for me: Tetralith: /home/x_birbr Kebnekaise: /home/b/bbrydsoe Cosmos: /home/bbrydsoe My laptop, ncc-1701: /home/bbrydsoe My home desktop, defiant: /home/bbrydsoe Note You can always use the command pwd to see the path to your current working directory! You can also always return to your home directory by giving the command cd and pressing enter . There are is also an \u201cenvironment variable\u201d that can be used as shortcut for the path: $HOME . We will talk more about (environment) variables later. pwd \u00b6 The command pwd ( p rint w orking d irectory) will print out the full pathname of the working directory to the screen. You can use this to find out which directory you are in. Example, in your home directory \u00b6 On Tetralith On Dardel On Alvis On Kebnekaise On Cosmos user x_birbr : [ x_birbr@tetralith3 ~ ] $ pwd /home/x_birbr [ x_birbr@tetralith3 ~ ] $ user bbrydsoe : bbrydsoe@login1:~> pwd /cfs/klemming/home/b/bbrydsoe bbrydsoe@login1:~> user brydso : [ brydso@alvis2 ~ ] $ pwd /cephyr/users/brydso/Alvis [ brydso@alvis2 ~ ] $ user bbrydsoe : b-an01 [ ~ ] $ pwd /home/b/bbrydsoe b-an01 [ ~ ] $ user bbrydsoe : [ bbrydsoe@cosmos1 ~ ] $ pwd /home/bbrydsoe [ bbrydsoe@cosmos1 ~ ] $ Example, in a directory named testdir \u00b6 On Tetralith, user x_birbr : [ x_birbr@tetralith3 testdir ] $ pwd /home/x_birbr/testdir [ x_birbr@tetralith3 testdir ] $ Example, in subdirectory mydir under directory testdir \u00b6 On Tetralith, user x_birbr : [ x_birbr@tetralith3 mydir ] $ pwd /home/x_birbr/testdir/mydir [ x_birbr@tetralith3 mydir ] $ ls - listing files/directories \u00b6 The ls command is used to list files and/or directories. If you just give the command ls with no flags, it will list all files and subdirectories in the current directory except for hidden files. ls [ flags ] [ directory ] This way you can to list files/subdirectories for any directory, but the default one is the one you are currently standing in. Some examples: ls / lists contents of the root directory ls .. lists the contents of the parent directory of the current ls ~ lists the contents of your user home directory ls * lists contents of current directory and subdirectories Commonly used flags -a lists content including hidden files and directories -l lists content in long table format (permissions, owners, size in bytes, modification date/time, file/directory name) -lh adds an extra column to above representing size of each file/directory -t lists content sorted by last modified date in descending order -tr lists content sorted by last modified date in ascending order -s list files with their sizes To get more flags, type ls --help or man ls in the terminal to see the manual. Tip You can often get more info on flags/options and usage for a Linux command with COMMAND --help man COMMAND where COMMAND is the Linux command you want information about, like ls , mkdir , etc. The output for a few of the flags, for a directory with two subdirectories and some files [ x_birbr@tetralith1 mytestdir ] $ ls myfile.txt myotherfile.txt testdir1 testdir2 [ x_birbr@tetralith1 mytestdir ] $ ls -a ./ ../ myfile.txt myotherfile.dat testdir1/ testdir2/ [ x_birbr@tetralith1 mytestdir ] $ ls -l total 3 -rw-rw-r-- 1 x_birbr x_birbr 27 Sep 11 11 :43 myfile.txt -rw-rw-r-- 1 x_birbr x_birbr 33 Sep 11 11 :43 myotherfile.txt drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :40 testdir1 drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :39 testdir2 [ x_birbr@tetralith1 mytestdir ] $ ls -la total 5 drwxrwxr-x 4 x_birbr x_birbr 4096 Sep 11 11 :43 . drwx------ 3 x_birbr x_birbr 4096 Sep 11 11 :43 .. -rw-rw-r-- 1 x_birbr x_birbr 27 Sep 11 11 :43 myfile.txt -rw-rw-r-- 1 x_birbr x_birbr 33 Sep 11 11 :43 myotherfile.txt drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :40 testdir1 drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :39 testdir2 [ x_birbr@tetralith1 mytestdir ] $ ls -lah total 5 .0K drwxrwxr-x 4 x_birbr x_birbr 4 .0K Sep 11 11 :43 . drwx------ 3 x_birbr x_birbr 4 .0K Sep 11 11 :43 .. -rw-rw-r-- 1 x_birbr x_birbr 27 Sep 11 11 :43 myfile.txt -rw-rw-r-- 1 x_birbr x_birbr 33 Sep 11 11 :43 myotherfile.txt drwxrwxr-x 2 x_birbr x_birbr 4 .0K Sep 11 11 :40 testdir1 drwxrwxr-x 2 x_birbr x_birbr 4 .0K Sep 11 11 :39 testdir2 [ x_birbr@tetralith1 mytestdir ] $ ls -latr total 5 drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :39 testdir2 drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :40 testdir1 -rw-rw-r-- 1 x_birbr x_birbr 27 Sep 11 11 :43 myfile.txt -rw-rw-r-- 1 x_birbr x_birbr 33 Sep 11 11 :43 myotherfile.txt drwx------ 3 x_birbr x_birbr 4096 Sep 11 11 :43 .. drwxrwxr-x 4 x_birbr x_birbr 4096 Sep 11 11 :43 . [ x_birbr@tetralith1 mytestdir ] $ ls * myfile.txt myotherfile.dat testdir1: file1.txt file2.sh file3.c file4.dat testdir2: file1.txt file2.txt file3.c [ x_birbr@tetralith1 mytestdir ] $ cd testdir1 b-an01 [ ~/mytestdir/testdir1 ] $ ls -l total 2 -rw-rw-r-- 1 x_birbr x_birbr 31 Sep 11 11 :47 file1.txt -rw-rw-r-- 1 x_birbr x_birbr 16 Sep 11 11 :49 file2.sh -rw-rw-r-- 1 x_birbr x_birbr 74 Sep 11 11 :49 file3.c -rw-rw-r-- 1 x_birbr x_birbr 25 Sep 11 11 :50 file4.dat [ x_birbr@tetralith1 mytestdir ] $ ls -ls total 2 1 -rw-rw-r-- 1 x_birbr x_birbr 31 Sep 11 11 :47 file1.txt 1 -rw-rw-r-- 1 x_birbr x_birbr 16 Sep 11 11 :49 file2.sh 1 -rw-rw-r-- 1 x_birbr x_birbr 74 Sep 11 11 :49 file3.c 1 -rw-rw-r-- 1 x_birbr x_birbr 25 Sep 11 11 :50 file4.dat The \u201cdrwxr-xr-x\u201d and \u201c-rw-r--r--\u201d are examples of permissions . The prefex d means is it a directory. A \u201c-\u201d means no permission for that. There are three groups: owner, group, and all. Note that \u201cr\u201d is for read, \u201cw\u201d is for write, and \u201cx\u201d is for execute. We will talk a bit more about permissions and how to change them when we come to the section on scripting . Wild cards \u00b6 Wild cards are useful \u201cstand-ins\u201d for one or more characters or numbers, that you can use for instance when finding patterns or when removing/listing all files of a certain type. Wild cards are also called \u201cglob\u201d or \u201cglobbing\u201d patterns. Globs Globs, also known as glob (or globbing) patterns are special characters that can expand a wildcard pattern into a list of pathnames that match the given pattern. On the early versions of Linux, the command interpreters relied on a program that expanded these characters into unquoted arguments to a command: /etc/glob . Common wildcards ? represents a single character. * represents a string of characters (0 or more). [ ] represents a range of alphanumeric characters in ascending order. { } the terms are separated by commas and each term must be a wildcard or exact name. [!] matches any character that is NOT listed between [! and ] . This is a logical NOT. \\ specifies an \u201cescape\u201d character, when using a subsequent special character. Warning You may need quotation marks around some wildcards as well. Warning Wildcards are typically case-sensitive by default. The [] expression in particular treats the set of all uppercase characters as preceding the set of all lowercase characters. For example [T-g] will match all uppercase letters from \u201cT\u201d through \u201cZ\u201d and all lowercase letters from \u201ca\u201d through \u201cg\u201d, but will not include uppercase \u201cG\u201d or lowercase \u201ct\u201d. Many relevant commands, like ls , have an -i flag to ignore case. Try some of the commands below Useful files for these examples are found in exercises/patterns . Some examples of the use of wildcards myfile?.txt This matches myfile0.txt, myfile1.txt,\u2026 for all letters from A to z and numbers from 0 through 9. Try with ls myfile?.txt . r*d This matches red, rad, ronald, \u2026 anything starting with r and ending with d, including rd. r [ a,i,o ] ck This matches rack, rick, and rock. a [ d-j ] a This matches ada, afa, aja, \u2026 and any three letter word that starts with an a, ends with an a, and has any character from d to j in between (but no capital letters). Try with ls a[d-j]a . [ 0 -9 ] This matches a range of numbers from 0 through 9. cp { *.dat,*.c,*.pdf } ~ This command copies any files ending in .dat, .c, and .pdf to the user\u2019s home directory. No spaces are allowed between the commas, etc. You could test it by creating a matching file in the patterns directory with touch file.c and running the above command to see it only copies that one from the patterns directory. rm thisfile [ !8 ] * This will remove all files named thisfile* , except those that have an 8 at that position in their name. Try running it in the patterns directory! Do ls before and after to see the change. Remember, you can always recreate the directory patterns by untarring it again. cd - changing directory \u00b6 The command cd is used to change directory. cd or cd ~ : Go to your home directory ($HOME) cd DIR : Change directory to DIR (whatever path you specify) cd .. : Change directory to the parent directory of the current directory cd - : go back to the previous working directory Example This is the structure of the exercises directory that you got after extracting the tarball: Remember, $HOME is an environment variable which gives a shortcut to your home directory. NOTE if you are on Tetralith and placed the exercises under /proj/spring-courses-naiss/users/USERNAME then $HOME would be replaced by that path. To change to the directory exercises when you are in your home directory, you do cd exercises To then change to the directory testdir1 you do cd testdir1 To quickly go back to your home directory, do cd To quickly go to a subdirectory, for instance exercises/testdir2 you then do cd exercises/testdir2 To go to the above directory from anywhere on the system in question, do cd $HOME /exercises/testdir2 Info You can use full paths (also known as absolute paths ) or relative paths to give the location. An absolute path makes no assumptions about your current location in relation to the location of the file or directory you want to access. It specifies the location from the root of the file system. Absolute paths are required if the file or directory you want to access is not in your current directory or any sub-directory therein. The path with reference to your current directory is called the relative path. A relative path only explicitly specifies sub-directories of your current directory, leaving the part of the path from the root to the current directory implicit. Summary Your home directory is generally located in /home/USERNAME or /home/U/USERNAME Your home directory is also stored as the environment variable $HOME pwd displays your path and current location cd DIR changes your current working directory to DIR Using cd without providing a destination takes you to your home directory ls is used to list files and directories Wildcards are metacharacters for one or more character or number, and are useful when you are finding patterns or removing/copying/listing all files of a certain type","title":"Navigating the File System"},{"location":"filesystem/#navigating__the__file__system","text":"This section will be a basic overview of the Linux filesystem concepts, not an in-depth description of filesystem types. Learning objectives Questions How do I change directory? How do I list my files? Learning objectives Learn how to navigate the Linux file system Learn about files and directories Learn about paths Learn about options (flags) and arguments to shell commands Learn about the tab completion The Linux filesystem directory structure starts with the top root directory, which is shown as / . Below this are several other standard directories. Of particular interest are usr/bin , home , usr/lib , and usr/lib64 . A common directory which you will also often find is usr/local/bin . The picture on the right shows typical subdirectories under / (note that the command tree does not work at all HPC centers, though it does work on Tetralith\u2014see the page tree under the \u201cExtras\u201d section for how to install if it is missing). Some of the directories have a symbolic link to a different name\u2014this is often done to make it quicker to write, but can also be for compatibility reasons since some software have hardcoded paths. Note The path or pathname is the representation of the location of a file or folder/directory on a computer file system. / is the root of the directory structure on a Linux filesystem /usr/bin contains (most) of the system-specific binaries /usr/local/bin holds non-system binaries. often locally compiled/maintained packages /home is where the home directories of the users of the system are located /usr/lib holds kernel modules and shared library images needed to boot the system and run commands in the root filesystem /usr/lib64 is the same as /usr/lib , just for 64-bit libraries User installed binaries are often located in /opt . The file system could also be illustrated like this: Note about / The character / can be the root directory, if it appears alone or at the front of a file or directory name a separator if it appears in other positions within the path. Note If you are on a local cluster, on an HPC center, etc. where you are not root, you will be in your home directory by default when you login. You can use cd .. a couple times to go to the root of the system and do tree there if you want, or do tree in your home directory (you can always return there with just cd ). Caution Running tree in / on a supercomputing center will probably give a very large/long output!","title":"Navigating the File System"},{"location":"filesystem/#home__folders__on__tetralith","text":"The above shows an illustration where the home folders are emphasized.","title":"Home folders on Tetralith"},{"location":"filesystem/#your__home__directory","text":"When you login to the computer (as a non root user), you will end up in your home directory. At most HPC centers, your home directory will appear as ~ in the terminal prompt, and can also be used in commands instead of having to type out /home/YOUR_USERNAME . The path to your home directory varies somewhat. Here are some examples for me: Tetralith: /home/x_birbr Kebnekaise: /home/b/bbrydsoe Cosmos: /home/bbrydsoe My laptop, ncc-1701: /home/bbrydsoe My home desktop, defiant: /home/bbrydsoe Note You can always use the command pwd to see the path to your current working directory! You can also always return to your home directory by giving the command cd and pressing enter . There are is also an \u201cenvironment variable\u201d that can be used as shortcut for the path: $HOME . We will talk more about (environment) variables later.","title":"Your home directory"},{"location":"filesystem/#pwd","text":"The command pwd ( p rint w orking d irectory) will print out the full pathname of the working directory to the screen. You can use this to find out which directory you are in.","title":"pwd"},{"location":"filesystem/#example__in__your__home__directory","text":"On Tetralith On Dardel On Alvis On Kebnekaise On Cosmos user x_birbr : [ x_birbr@tetralith3 ~ ] $ pwd /home/x_birbr [ x_birbr@tetralith3 ~ ] $ user bbrydsoe : bbrydsoe@login1:~> pwd /cfs/klemming/home/b/bbrydsoe bbrydsoe@login1:~> user brydso : [ brydso@alvis2 ~ ] $ pwd /cephyr/users/brydso/Alvis [ brydso@alvis2 ~ ] $ user bbrydsoe : b-an01 [ ~ ] $ pwd /home/b/bbrydsoe b-an01 [ ~ ] $ user bbrydsoe : [ bbrydsoe@cosmos1 ~ ] $ pwd /home/bbrydsoe [ bbrydsoe@cosmos1 ~ ] $","title":"Example, in your home directory"},{"location":"filesystem/#example__in__a__directory__named__testdir","text":"On Tetralith, user x_birbr : [ x_birbr@tetralith3 testdir ] $ pwd /home/x_birbr/testdir [ x_birbr@tetralith3 testdir ] $","title":"Example, in a directory named testdir"},{"location":"filesystem/#example__in__subdirectory__mydir__under__directory__testdir","text":"On Tetralith, user x_birbr : [ x_birbr@tetralith3 mydir ] $ pwd /home/x_birbr/testdir/mydir [ x_birbr@tetralith3 mydir ] $","title":"Example, in subdirectory mydir under directory testdir"},{"location":"filesystem/#ls__-__listing__filesdirectories","text":"The ls command is used to list files and/or directories. If you just give the command ls with no flags, it will list all files and subdirectories in the current directory except for hidden files. ls [ flags ] [ directory ] This way you can to list files/subdirectories for any directory, but the default one is the one you are currently standing in. Some examples: ls / lists contents of the root directory ls .. lists the contents of the parent directory of the current ls ~ lists the contents of your user home directory ls * lists contents of current directory and subdirectories Commonly used flags -a lists content including hidden files and directories -l lists content in long table format (permissions, owners, size in bytes, modification date/time, file/directory name) -lh adds an extra column to above representing size of each file/directory -t lists content sorted by last modified date in descending order -tr lists content sorted by last modified date in ascending order -s list files with their sizes To get more flags, type ls --help or man ls in the terminal to see the manual. Tip You can often get more info on flags/options and usage for a Linux command with COMMAND --help man COMMAND where COMMAND is the Linux command you want information about, like ls , mkdir , etc. The output for a few of the flags, for a directory with two subdirectories and some files [ x_birbr@tetralith1 mytestdir ] $ ls myfile.txt myotherfile.txt testdir1 testdir2 [ x_birbr@tetralith1 mytestdir ] $ ls -a ./ ../ myfile.txt myotherfile.dat testdir1/ testdir2/ [ x_birbr@tetralith1 mytestdir ] $ ls -l total 3 -rw-rw-r-- 1 x_birbr x_birbr 27 Sep 11 11 :43 myfile.txt -rw-rw-r-- 1 x_birbr x_birbr 33 Sep 11 11 :43 myotherfile.txt drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :40 testdir1 drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :39 testdir2 [ x_birbr@tetralith1 mytestdir ] $ ls -la total 5 drwxrwxr-x 4 x_birbr x_birbr 4096 Sep 11 11 :43 . drwx------ 3 x_birbr x_birbr 4096 Sep 11 11 :43 .. -rw-rw-r-- 1 x_birbr x_birbr 27 Sep 11 11 :43 myfile.txt -rw-rw-r-- 1 x_birbr x_birbr 33 Sep 11 11 :43 myotherfile.txt drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :40 testdir1 drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :39 testdir2 [ x_birbr@tetralith1 mytestdir ] $ ls -lah total 5 .0K drwxrwxr-x 4 x_birbr x_birbr 4 .0K Sep 11 11 :43 . drwx------ 3 x_birbr x_birbr 4 .0K Sep 11 11 :43 .. -rw-rw-r-- 1 x_birbr x_birbr 27 Sep 11 11 :43 myfile.txt -rw-rw-r-- 1 x_birbr x_birbr 33 Sep 11 11 :43 myotherfile.txt drwxrwxr-x 2 x_birbr x_birbr 4 .0K Sep 11 11 :40 testdir1 drwxrwxr-x 2 x_birbr x_birbr 4 .0K Sep 11 11 :39 testdir2 [ x_birbr@tetralith1 mytestdir ] $ ls -latr total 5 drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :39 testdir2 drwxrwxr-x 2 x_birbr x_birbr 4096 Sep 11 11 :40 testdir1 -rw-rw-r-- 1 x_birbr x_birbr 27 Sep 11 11 :43 myfile.txt -rw-rw-r-- 1 x_birbr x_birbr 33 Sep 11 11 :43 myotherfile.txt drwx------ 3 x_birbr x_birbr 4096 Sep 11 11 :43 .. drwxrwxr-x 4 x_birbr x_birbr 4096 Sep 11 11 :43 . [ x_birbr@tetralith1 mytestdir ] $ ls * myfile.txt myotherfile.dat testdir1: file1.txt file2.sh file3.c file4.dat testdir2: file1.txt file2.txt file3.c [ x_birbr@tetralith1 mytestdir ] $ cd testdir1 b-an01 [ ~/mytestdir/testdir1 ] $ ls -l total 2 -rw-rw-r-- 1 x_birbr x_birbr 31 Sep 11 11 :47 file1.txt -rw-rw-r-- 1 x_birbr x_birbr 16 Sep 11 11 :49 file2.sh -rw-rw-r-- 1 x_birbr x_birbr 74 Sep 11 11 :49 file3.c -rw-rw-r-- 1 x_birbr x_birbr 25 Sep 11 11 :50 file4.dat [ x_birbr@tetralith1 mytestdir ] $ ls -ls total 2 1 -rw-rw-r-- 1 x_birbr x_birbr 31 Sep 11 11 :47 file1.txt 1 -rw-rw-r-- 1 x_birbr x_birbr 16 Sep 11 11 :49 file2.sh 1 -rw-rw-r-- 1 x_birbr x_birbr 74 Sep 11 11 :49 file3.c 1 -rw-rw-r-- 1 x_birbr x_birbr 25 Sep 11 11 :50 file4.dat The \u201cdrwxr-xr-x\u201d and \u201c-rw-r--r--\u201d are examples of permissions . The prefex d means is it a directory. A \u201c-\u201d means no permission for that. There are three groups: owner, group, and all. Note that \u201cr\u201d is for read, \u201cw\u201d is for write, and \u201cx\u201d is for execute. We will talk a bit more about permissions and how to change them when we come to the section on scripting .","title":"ls - listing files/directories"},{"location":"filesystem/#wild__cards","text":"Wild cards are useful \u201cstand-ins\u201d for one or more characters or numbers, that you can use for instance when finding patterns or when removing/listing all files of a certain type. Wild cards are also called \u201cglob\u201d or \u201cglobbing\u201d patterns. Globs Globs, also known as glob (or globbing) patterns are special characters that can expand a wildcard pattern into a list of pathnames that match the given pattern. On the early versions of Linux, the command interpreters relied on a program that expanded these characters into unquoted arguments to a command: /etc/glob . Common wildcards ? represents a single character. * represents a string of characters (0 or more). [ ] represents a range of alphanumeric characters in ascending order. { } the terms are separated by commas and each term must be a wildcard or exact name. [!] matches any character that is NOT listed between [! and ] . This is a logical NOT. \\ specifies an \u201cescape\u201d character, when using a subsequent special character. Warning You may need quotation marks around some wildcards as well. Warning Wildcards are typically case-sensitive by default. The [] expression in particular treats the set of all uppercase characters as preceding the set of all lowercase characters. For example [T-g] will match all uppercase letters from \u201cT\u201d through \u201cZ\u201d and all lowercase letters from \u201ca\u201d through \u201cg\u201d, but will not include uppercase \u201cG\u201d or lowercase \u201ct\u201d. Many relevant commands, like ls , have an -i flag to ignore case. Try some of the commands below Useful files for these examples are found in exercises/patterns . Some examples of the use of wildcards myfile?.txt This matches myfile0.txt, myfile1.txt,\u2026 for all letters from A to z and numbers from 0 through 9. Try with ls myfile?.txt . r*d This matches red, rad, ronald, \u2026 anything starting with r and ending with d, including rd. r [ a,i,o ] ck This matches rack, rick, and rock. a [ d-j ] a This matches ada, afa, aja, \u2026 and any three letter word that starts with an a, ends with an a, and has any character from d to j in between (but no capital letters). Try with ls a[d-j]a . [ 0 -9 ] This matches a range of numbers from 0 through 9. cp { *.dat,*.c,*.pdf } ~ This command copies any files ending in .dat, .c, and .pdf to the user\u2019s home directory. No spaces are allowed between the commas, etc. You could test it by creating a matching file in the patterns directory with touch file.c and running the above command to see it only copies that one from the patterns directory. rm thisfile [ !8 ] * This will remove all files named thisfile* , except those that have an 8 at that position in their name. Try running it in the patterns directory! Do ls before and after to see the change. Remember, you can always recreate the directory patterns by untarring it again.","title":"Wild cards"},{"location":"filesystem/#cd__-__changing__directory","text":"The command cd is used to change directory. cd or cd ~ : Go to your home directory ($HOME) cd DIR : Change directory to DIR (whatever path you specify) cd .. : Change directory to the parent directory of the current directory cd - : go back to the previous working directory Example This is the structure of the exercises directory that you got after extracting the tarball: Remember, $HOME is an environment variable which gives a shortcut to your home directory. NOTE if you are on Tetralith and placed the exercises under /proj/spring-courses-naiss/users/USERNAME then $HOME would be replaced by that path. To change to the directory exercises when you are in your home directory, you do cd exercises To then change to the directory testdir1 you do cd testdir1 To quickly go back to your home directory, do cd To quickly go to a subdirectory, for instance exercises/testdir2 you then do cd exercises/testdir2 To go to the above directory from anywhere on the system in question, do cd $HOME /exercises/testdir2 Info You can use full paths (also known as absolute paths ) or relative paths to give the location. An absolute path makes no assumptions about your current location in relation to the location of the file or directory you want to access. It specifies the location from the root of the file system. Absolute paths are required if the file or directory you want to access is not in your current directory or any sub-directory therein. The path with reference to your current directory is called the relative path. A relative path only explicitly specifies sub-directories of your current directory, leaving the part of the path from the root to the current directory implicit. Summary Your home directory is generally located in /home/USERNAME or /home/U/USERNAME Your home directory is also stored as the environment variable $HOME pwd displays your path and current location cd DIR changes your current working directory to DIR Using cd without providing a destination takes you to your home directory ls is used to list files and directories Wildcards are metacharacters for one or more character or number, and are useful when you are finding patterns or removing/copying/listing all files of a certain type","title":"cd - changing directory"},{"location":"hints/","text":"Hints and tricks \u00b6 This section contains some hints that might make working with Linux easier. Tab auto-complete \u00b6 If you press TAB on the keyboard after starting to type a command or a file, it will auto-complete if no other matches or else suggest possible matches. Short-cuts on the CLI \u00b6 CTRL-SOMEKEY refers to pressing down the CTRL key and then another key while continuing to hold down CTRL. Examples: CTRL-a : Go to the beginning of the line CTRL-e : Go to the end of the line CTRL-l : Clear the terminal TAB : Auto-complete (i.e. start write a command or file name and then press TAB to auto-complete as far as possible ARROW-UP : Pressing the arrow-up key repeatedly will let you cycle through recent commands CTRL-r : you will get a prompt to write text to search in the list of recent commands. The list is saved in .bash_history in your $HOME. On some systems it might be called .bash.history Finding help \u00b6 You can often get more info on the usage of a Linux command. This includes options and flags. Depending on the setup of your system either or both of the following should succeed: COMMAND --help man COMMAND where COMMAND is the Linux command you want information about, like ls , mkdir , gcc , etc. Misc \u00b6 Type clear to clear the terminal Type history to see a list of the recent commands used in the terminal You can change the number of saved commands by setting the environment variable HISTSIZE in your .bashrc file in your home directory. Example: Open .bashrc with nano . Somewhere (at the end for instance) add: export HISTSIZE=NUMBER where NUMBER is the number of commands to save, for instance 500. Warning Passwords in the history file If you enter a password (e.g. login password for a computer or website) at the command prompt and hit return, the password will be included into the .bash_history file once you log off. Neither the password nor the history file are encrypted in any way. In particular when using a shared system such as offered by NAISS, it is best to reset the password on the computer or website where you have been using it, to a new value.","title":"Hints and tricks"},{"location":"hints/#hints__and__tricks","text":"This section contains some hints that might make working with Linux easier.","title":"Hints and tricks"},{"location":"hints/#tab__auto-complete","text":"If you press TAB on the keyboard after starting to type a command or a file, it will auto-complete if no other matches or else suggest possible matches.","title":"Tab auto-complete"},{"location":"hints/#short-cuts__on__the__cli","text":"CTRL-SOMEKEY refers to pressing down the CTRL key and then another key while continuing to hold down CTRL. Examples: CTRL-a : Go to the beginning of the line CTRL-e : Go to the end of the line CTRL-l : Clear the terminal TAB : Auto-complete (i.e. start write a command or file name and then press TAB to auto-complete as far as possible ARROW-UP : Pressing the arrow-up key repeatedly will let you cycle through recent commands CTRL-r : you will get a prompt to write text to search in the list of recent commands. The list is saved in .bash_history in your $HOME. On some systems it might be called .bash.history","title":"Short-cuts on the CLI"},{"location":"hints/#finding__help","text":"You can often get more info on the usage of a Linux command. This includes options and flags. Depending on the setup of your system either or both of the following should succeed: COMMAND --help man COMMAND where COMMAND is the Linux command you want information about, like ls , mkdir , gcc , etc.","title":"Finding help"},{"location":"hints/#misc","text":"Type clear to clear the terminal Type history to see a list of the recent commands used in the terminal You can change the number of saved commands by setting the environment variable HISTSIZE in your .bashrc file in your home directory. Example: Open .bashrc with nano . Somewhere (at the end for instance) add: export HISTSIZE=NUMBER where NUMBER is the number of commands to save, for instance 500. Warning Passwords in the history file If you enter a password (e.g. login password for a computer or website) at the command prompt and hit return, the password will be included into the .bash_history file once you log off. Neither the password nor the history file are encrypted in any way. In particular when using a shared system such as offered by NAISS, it is best to reset the password on the computer or website where you have been using it, to a new value.","title":"Misc"},{"location":"intro/","text":"Introduction to Linux \u00b6 Welcome page and syllabus: https://hpc2n.github.io/linux-command-line-101/intro/ Also linked at the mini terminal on the top left of the page. What is Linux \u00b6 Note Most of the commands you learn in this course are agnostic and should work on any Linux/Unix like system. macOS is a Unix based operating system, and the majority of the commands are the same. Linux is a family of open-source Unix-like operating systems based on the Linux kernel, an operating system kernel first released on September 17, 1991, by Linus Torvalds. An operating system kernel is the software that sits underneath all of the other software on a computer, managing the computer\u2019s hardware (CPU, GPU, memory, storage\u2026) and handling the connections between your other software and the hardware. Linux is: Multitasking capable Multi user system Open source Free of charge Linux is typically packaged as a Linux distribution, which includes the kernel and supporting system software and libraries, many of which are provided by the GNU Project. In addition, a windowing system of some sort (X11, Wayland) interfaces directly with the underlying operating system and libraries, providing support for graphical hardware, pointing devices, and keyboards. The window manager generally runs on top of this windowing system. Distributions (distros) There are many Linux distribuitions, including Ubuntu, Debian, Fedora, Gentoo, and many others. Most distributions are free and open source, but there are also commercial distributions, like Red Hat Enterprise and SUSE. Desktop Linux distributions include a desktop environment , like GNOME, MATE, KDE Plasma, Xfce, Unity, or many others. Most of what the user sees is provided by a window manager and applications written using a widget toolkit. Shells \u00b6 A shell is an interface between the keyboard and the operating system (OS), i.e., it takes commands the user gives via the keyboard and sends it to the OS. The OS then performs the actions requested. There are several shells designed to work with Linux/Unix systems, each of which has somewhat different properties and syntax: The Bourne Shell (sh) The GNU Bourne-Again shell (bash) The C shell (csh) The TENEX C shell (tcsh) The Korn Shell (ksh) The Z Shell (zsh) Important Most centers have bash as default. There are several reasons, but one is that it compatible with SLURM\u2014the batch scheduler used at most centers in Sweden. The bash shell is also good for scripting. For the majority of the material in this course, it does not matter which shell you are using, but there are some commands where it is relevant. We will therefore be using bash for this course. Why Linux/Unix (shell) \u00b6 The Linux/Unix shell has existed for a very long time (Thompson shell, 1971; Bourne shell, 1979). It continues to be used because it is a very powerful tool that lets users perform complex tasks. These tasks can often be done using a few keystrokes or maybe a few lines of code. It can be used to automate repetitive tasks or to combine smaller tasks into scripts , which helps the user work faster and more effectively. Using the Linux/Unix shell is fundamental for a large number of advanced computing tasks, including in HPC (high-performance computing). In addition, most HPC clusters run some flavour of Linux because it: Is stable and reliable Is customisable Is lightweight Runs on any hardware Has a strong support community Has many flavours that are open-source and free Has lots of applications While Linux is only used on about 3% of desktops, the vast majority of web servers (>96%), most mobile devices (Android is based on the Linux kernel), and all supercomputers on the Top500 list run Linux. In line with this: NAISS services use Linux . For all of these reasons, and many more, it is a good idea to be proficient in Linux. This course aims to help you with that. See also There is much more information about Linux on Wikipedia . Some pages with guides and/or cheat sheets: The Linux Handbook https://www.geeksforgeeks.org/linux-tutorial/ 14 Free Training Courses to Learn Linux Online Introduction to Linux - A Hands on Guide Linux Fundamentals Top 50+ Linux Commands You MUST Know","title":"Introduction"},{"location":"intro/#introduction__to__linux","text":"Welcome page and syllabus: https://hpc2n.github.io/linux-command-line-101/intro/ Also linked at the mini terminal on the top left of the page.","title":"Introduction to Linux"},{"location":"intro/#what__is__linux","text":"Note Most of the commands you learn in this course are agnostic and should work on any Linux/Unix like system. macOS is a Unix based operating system, and the majority of the commands are the same. Linux is a family of open-source Unix-like operating systems based on the Linux kernel, an operating system kernel first released on September 17, 1991, by Linus Torvalds. An operating system kernel is the software that sits underneath all of the other software on a computer, managing the computer\u2019s hardware (CPU, GPU, memory, storage\u2026) and handling the connections between your other software and the hardware. Linux is: Multitasking capable Multi user system Open source Free of charge Linux is typically packaged as a Linux distribution, which includes the kernel and supporting system software and libraries, many of which are provided by the GNU Project. In addition, a windowing system of some sort (X11, Wayland) interfaces directly with the underlying operating system and libraries, providing support for graphical hardware, pointing devices, and keyboards. The window manager generally runs on top of this windowing system. Distributions (distros) There are many Linux distribuitions, including Ubuntu, Debian, Fedora, Gentoo, and many others. Most distributions are free and open source, but there are also commercial distributions, like Red Hat Enterprise and SUSE. Desktop Linux distributions include a desktop environment , like GNOME, MATE, KDE Plasma, Xfce, Unity, or many others. Most of what the user sees is provided by a window manager and applications written using a widget toolkit.","title":"What is Linux"},{"location":"intro/#shells","text":"A shell is an interface between the keyboard and the operating system (OS), i.e., it takes commands the user gives via the keyboard and sends it to the OS. The OS then performs the actions requested. There are several shells designed to work with Linux/Unix systems, each of which has somewhat different properties and syntax: The Bourne Shell (sh) The GNU Bourne-Again shell (bash) The C shell (csh) The TENEX C shell (tcsh) The Korn Shell (ksh) The Z Shell (zsh) Important Most centers have bash as default. There are several reasons, but one is that it compatible with SLURM\u2014the batch scheduler used at most centers in Sweden. The bash shell is also good for scripting. For the majority of the material in this course, it does not matter which shell you are using, but there are some commands where it is relevant. We will therefore be using bash for this course.","title":"Shells"},{"location":"intro/#why__linuxunix__shell","text":"The Linux/Unix shell has existed for a very long time (Thompson shell, 1971; Bourne shell, 1979). It continues to be used because it is a very powerful tool that lets users perform complex tasks. These tasks can often be done using a few keystrokes or maybe a few lines of code. It can be used to automate repetitive tasks or to combine smaller tasks into scripts , which helps the user work faster and more effectively. Using the Linux/Unix shell is fundamental for a large number of advanced computing tasks, including in HPC (high-performance computing). In addition, most HPC clusters run some flavour of Linux because it: Is stable and reliable Is customisable Is lightweight Runs on any hardware Has a strong support community Has many flavours that are open-source and free Has lots of applications While Linux is only used on about 3% of desktops, the vast majority of web servers (>96%), most mobile devices (Android is based on the Linux kernel), and all supercomputers on the Top500 list run Linux. In line with this: NAISS services use Linux . For all of these reasons, and many more, it is a good idea to be proficient in Linux. This course aims to help you with that. See also There is much more information about Linux on Wikipedia . Some pages with guides and/or cheat sheets: The Linux Handbook https://www.geeksforgeeks.org/linux-tutorial/ 14 Free Training Courses to Learn Linux Online Introduction to Linux - A Hands on Guide Linux Fundamentals Top 50+ Linux Commands You MUST Know","title":"Why Linux/Unix (shell)"},{"location":"linux-terminology/","text":"Linux terminology \u00b6 This section will give an overview of some of the most common terminology of Linux, as it may not be familiar to someone coming from i.e. Windows. It is, however, useful to know the meaning of some of the terms you will often see when searching for information about Linux or anything done on a Linux system. For a more detailed list of Linux terminology, there is a link to a Glossary of Linux Terms . Linux \u00b6 While we usually think of Linux as an operating system, that is not strictly true; Linux is a free and open-source kernel developed by Linus Torvalds in 1991. Kernel \u00b6 \u2018Kernels\u2019 are at the core of every Operating System (OS). Note A kernel manages your system\u2019s hardware, as well as all the programs on your computer. When, for instance, you press a key on your keyboard or use your mouse to click a button on the screen, this information gets sent through the kernel. It will then communicate with the operating system, to use the data as input and to show the output using the hardware (in this case the monitor). Linux : the base Linux kernel is open-source. A large number of distributions (distros) use this core. They then modify it to lesser or greater extent, suiting their particular goals. The Linux kernel: - is the core component of the Linux OS - is open source and actively developed by a large community - manages hardware resources - handles communication between software and hardware - is in charge of - device drivers - process management - memory management - other low-level system operations Distributions (distros) \u00b6 Note Different versions of Linux are called distributions or \u201cdistros\u201d. There are a large number of Linux distributions, as anyone can create their own Linux distro. It is thus important to check at least the most popular distros if you are considering to switch to another operating system. Some are easier to use than others. Examples of popular Linux distros are: Ubuntu, Debian, Fedora, CentOS, Slackware, Gentoo, Arch, Mint, and many others. Note Many distros can be downloaded and put on a bootable USB, so you can try them out before deciding. Any operating system that uses the Linux kernel is called a Linux distribution (\u201cdistro\u201d). The reason for that name comes from sharing , or distributing the Linux OS (usually for free). Aside from distributions, developers make customized versions of the various \u201cmainstream\u201d Linux distributions. These are called remixes , flavours, and spins . Often the differences are choices of packages, desktop environments, etc. There is no hard difference between calling the customized versions remixes, flavours, or spins - it is mainly a choice. A distro is a complete operating system, including - the Linux kernel - software packages - various tools and utilities The different spins/flavours of that distro could have - different package managers - desktop environments - various other features. Example: Ubuntu The distro Ubuntu has several flavors : Xubuntu, Lubuntu, Kubuntu, etc. each which has a different desktop environment. Example: \u201cFedora The distro Fedora uses the expression spins for its derivatives. Desktop environments \u00b6 To make it easier for users to work on their computer, many operating systems have a desktop that offers a graphical interface manage the system. Windows and macOS are common examples. Linux also has (optional) desktop(s), but things are done a little different. Linux offers a great many desktops, which are called \u201cdesktop environments\u201d. The vast majority of those are available to install for free. Desktop environments (usually) come with a program called a \u201cwindow manager\u201d, as well as apps and widgets that, combined with the window manager, makes for a better user interface that can be further customized. Note Popular desktop environments are GNOME, KDE Plasma, XFCE, Pantheon, LXDE, and many more. Window managers \u00b6 Window managers: - are programs controlling placement and movement of windows on your screen - usually work together with desktop environments - can also be used separately on your Linux machine - are lightweight and can offer better performance than desktop environments - do not ship with unnecessary apps and widget (you even have to install menu and compositor if you go with just a window manager) - can be complicated to set up for non-technical users, since you need to install everything extra yourself Note Some of the popular window managers are: i3wm, bspwm, awesome, Fluxbox KDE Plasma and GNOME desktops use the KWin and Mutter window managers \u201cunder the hood\u201d \u201cGNU Network Object Model Environment (GNOME)\u201d is a desktop environment used by several Linux distros. It is quite similar to the Windows desktop and can be a good choice if you are changing from that OS Commands \u00b6 The prompts that you type on the terminal are called \u201ccommands\u201d. The terminal is also commonly called the \u201ccommand line\u201d or the \u201ccommand line interface\u201d (CLI). There are several applications that can be used to access the command line, so it will vary how it looks, but it is usually a simple window (commonly white or green on black background or black on white background). Using commands on a command line interface is something many people find to be the most intimidating thing about Linux. However, while the command line is an integral part of using Linux, and some actions may be faster or more direct when done on the command line, most things can actually be done through a Graphical User Interface (GUI). Command line interface (CLI), terminal \u00b6 The terminal, console, or \u201ccommand line interface\u201d (often abbreviated \u201cCLI\u201d) is a text.based interface which is often the primary way to interact with Linux. The terminal is where you enter your \u201ccommands\u201d . It is usually very straightforward and simple, but you can also choose to use a terminal emulator which will give you a more user-friendly interface. It is a program that is used to control your operating system\u2019s \u201cshell\u201d . Briefly; a shell is a text-based (or graphical interface) through which the user interact with the desktop. Note The Linux terminal is similar to \u201cCommand Prompt\u201d on Windows. It is used by the \u201csuper user\u201d or \u201cadministrator\u201d to control and manage the system efficiently. It can be used to configure settings, for scripting, directly controlling the system, as well as giving various other commands to any program on the system. While other operating systems like Windows once regularly used something like a terminal, it is now more seldom used except for some administrative management. On Linux, however, the terminal is still very much used. This may surprise some, but there are several good reasons: The command line is fast: The CLI is usually much faster than using a GUI, and command-line programs will also start faster that graphical programs due to less overhead. Many programming tools use the command line: compilers, interpreters, debuggers all run on the command line. Yes, there are often a graphical IDE you can install, but that is just a wrapper for the command line program. The command line works everywhere: it is easy to use remotely through SSH, for installing and maintaining servers, you can use it without starting a graphical interface, which gives less overhead and makes it faster and more efficient You can script command line programs: this is a big advantage; you can avoid many repetitive operations when using a script Example: renaming, copying, or moving many files through a graphical file manager can be a hassle. On the command line you can script it. For instance, copying all your .dat files to a directory could be done like this: cp *.dat /mydir You can also use scripting for more complicated tasks. Some of the most commonly used scripting languages are the shell, perl, and Python. Root, user \u00b6 All Linux operating systems have a built-in system of user roles, where each user has a specific role, with varying levels of permissions. Some of the common roles are: - user: nothing more, nothing less. The user can normally do what they want in their own home directory and perhaps a few other directories where they have been given permission to work. A user cannot install anything to the system outside of these directories where they have permission, and also cannot change most setup files (other than those affecting only themself). - root: The root user or root account has administrative priviliges; complete access to all configurations, commands, and files in the system. Other words for root is superuser or administrator , though root is the most common term on Linux. Note root refers to both the root directory and the root user . The root directory is the top level/parent directory containing all files and folders of the system. It is designated with a \u201c/\u201d, and this is how you can denote it in your commands. Package manager \u00b6 On Linux, the programs you install are often referred to as \u201cpackages\u201d. Commonly, they are installed on the command line. A \u201cpackage manager\u201d is a tool that gives you a graphical interface to help you find new packages, install, update, and sometimes even configure them. On Linux, most apps are distributed as packages and are available in the official repositories of your distribution. You can also add third-party repositories with a package manager if you want access to even more packages. There are several different package managers available for the different Linux distros. These are some of the popular ones: - APT: used by Debian and Ubuntu-based distributions. - RPM: used by Fedora, CentOS, and RHEL. - pacman: used by Arch Linux and its derivatives. - yum/dnf: used by Red Hat-based distributions. Source and binary packages \u00b6 Source packages: these contain the source code of a program: A user must manually compile and install it to run the software. Binary packages: these contain prebuilt and pre-compiled executables for the software. Repositories \u00b6 Collections of packages and their metadata can be found in software repositories on remote servers. Most Linux distros has their own set of repositories or else they use the repositories of their parent distro. Open Source \u00b6 Wikipedia defines Open Source as: Source code that is made freely available for possible modification and redistribution. Products include permission to use the source code, design documents, or content of the product. The open-source model is a decentralized software development model that encourages open collaboration. A main principle of open-source software development is peer production, with products such as source code, blueprints, and documentation freely available to the public. The open-source movement in software began as a response to the limitations of proprietary code. Open source has played a significant role in the growth and popularity of Linux. Process \u00b6 Each program you start on your system will run a number of processes in the background. A process is the instance of a running program which does the computation. It is the allocation of memory for the program as well as a thread for execution. Examples that launches a process or a set of processes You start a program, maybe a game You start your web browser You open a new tab in your web browser You run a command in a terminal All programs depends on processes to run and produce output. Note In Linux a process refers to a running instance of a program or command. Each process has a unique process ID (PID) Each process also has associated system resources (memory, file descriptors, etc) There are robust process management capabilities. Users can start, terminate, monitor processes, control their execution, manage system resources Shells \u00b6 A Shell is a command-line interpreter which provides an interface for users to interact with the operating system. There are several different shells: Bash (Bourne Again Shell), C Shell, Korn Shell, and Zsh, etc. Shells allow users to: - execute commands - run scripts - perform system operations Shells provide features like: - command history - input/output redirection - variables - control structures The two main \u201cfamilies\u201d of shells are C-shell and Bourne shell. csh : The C shell (csh or the improved version, tcsh) is a Unix shell created by Bill Joy while he was a graduate student at University of California, Berkeley in the late 1970s. The C shell is a command processor which is typically run in a text window, allowing the user to type and execute commands. The C shell can also read commands from a file, called a script. The style of the shell script language resembles C. tcsh : a Unix shell based on and backward compatible with the C shell (csh). It is essentially the C shell with programmable command-line completion, command-line editing, and a few other features. Unlike the other common shells, functions cannot be defined in a tcsh script and the user must use aliases instead (as in csh). sh : The Bourne shell (sh) is a shell command-line interpreter for computer operating systems, developed by Stephen Bourne at Bell Labs. It is used as an interactive command interpreter, but was also intended as a scripting language and contains most of the features that are commonly considered to produce structured programs. bash : (Bourne Again Shell). It provides a command-line interface for interacting with the operating system and executing commands. Bash offers features like command history, tab completion, scripting capabilities, and extensive support for shell scripting, making it a powerful tool for system administration and automation. ksh : KornShell. It is a Unix shell which was developed by David Korn at Bell Labs in the early 1980s. KornShell is backward-compatible with the Bourne shell and includes many features of the C shell, inspired by the requests of Bell Labs users. zsh : The Z shell (Zsh) is a Unix shell that can be used as an interactive login shell and as a command interpreter for shell scripting. Zsh is an extended Bourne shell with many improvements, including some features of Bash, ksh, and tcsh. Bash and tcsh are probably the most \u201cpopular\u201d of the shells. Shell Scripting \u00b6 A shell script is a computer program designed to be run by a Unix shell, a command-line interpreter. When you write several Linux commands and place them together in a single file, the resulting file is called a \u201cshell script.\u201d Shell scripting is the process of writing scripts using Linux commands, which are then interpreted by the shell installed on your system. Note The Windows equivalent to shell scripts are \u201cbatch scripts\u201d. Do NOT confuse these with the batch scripts used by batch systems! The most popular shell scripting language is Bash scripting - this means writing and executing scripts using the Bash shell. File system \u00b6 A file system provides a data storage service that allows applications to share mass storage. Without a file system, applications could access the storage in incompatible ways that lead to resource contention, data corruption and data loss. A File System is a method or structure the operating system uses to organize and store files on disk or other storage devices. Note Linux supports several different file systems, including ext4, XFS, Btrfs, and NTFS. These file systems has different features, performance characteristics, and compatibility with other operating systems. GNU \u00b6 GNU is an extensive collection of free software, which can be used as an operating system or can be used in parts with other operating systems. The use of the completed GNU tools led to the family of operating systems popularly known as Linux. Most of GNU is licensed under the GNU Project\u2019s own General Public License.i GNU is a recursive acronym for \u201cGNU\u2019s Not Unix\u201d. The Linux kernel is licensed under GNU\u2019s GPL (General Public License) and is thus known as GNU/Linux. Any operating system developed using the open-source GNU tools and the Linux kernel falls under the category of Linux distributions. Advanced \u00b6 There are many other terms which you may come across when reading about Linux. These are a few of them. Bootloader, grub \u00b6 Note A bootloader is a program responsible for booting your computer. When a computer is turned off, its software - including the operating systems, application code, and data - remains stored on non-volatile memory. The computer normally does not have an operating system or its loader in random-access memory (RAM) when it is powered on. First the computer executes a small program (the boot loader) stored in read-only memory (ROM) along with some needed data, to initialize RAM, to access the nonvolatile device (storage system like HDD) or devices from which the operating system programs and data can be loaded into RAM. GRUB is one of the most used bootloaders, including when dual-booting Windows with Linux. Other examples include LILO, BURG, and Syslinux. Encryption \u00b6 Encryption scrambles data into a secure and unreadable form so it can only be accessed by authorized parties. Linux provides encryption to secure data, both during transmission and on the system. This is done through encrypted file systems, disk encryption, and network encryption. IP Address (Internet Protocol Address) \u00b6 (Much of this section was taken from Wikipedia) An Internet Protocol address (IP address) is a unique numerical label that is assigned to every device that is connected to a network. IP addresses in Linux are used for: - network configuration - routing - device communication IP addresses can either be assigned manually (static IP address) or dynamically (DHCP). They are crucially important in establishing network connections and enabling internet connectivity. Two versions of the Internet Protocol are in common use on the Internet today: - The original version of the Internet Protocol (deployed in 1983 in the ARPANET) is Internet Protocol version 4 (IPv4). - An IPv4 address has a size of 32 bits, which limits the address space to 4294967296 (232) addresses. Some addresses are reserved for special purposes such as private networks (\u224818 million addresses) and multicast addressing (\u2248270 million addresses). - IPv4 addresses are usually represented in dot-decimal notation, consisting of four decimal numbers, each ranging from 0 to 255, separated by dots, e.g., 192.0.2.1. Each part represents a group of 8 bits (an octet) of the address. - The Internet Protocol Version 6 (IPv6) was developed in 1995. IPv6 technology was in various testing stages until the mid-2000s when commercial production deployment commenced. - In IPv6, the address size was increased from 32 bits in IPv4 to 128 bits, thus providing up to 2128 (approximately 3.403\u00d71038) addresses. This is deemed sufficient for the foreseeable future. Kernel Panic \u00b6 Kernel Panic is a critical error condition in the Linux kernel. When this happens it cannot continue operating safely. The reason for it happening is usually severe software or hardware issues, such as: a corrupted kernel, hardware failure, or incompatible drivers. The system halts when there is a kernel panic. An error message is displayed, and a manual reboot needs to be done. Kernel panics happen quite rarely, but are something that gives cause for concernt and needs to be investigated so the cause can be found and resolved. Mount \u00b6 Mounting means to attach a file system to a specific directory location in the Linux file hierarchy. This causes the contents of the file system to become accessible to the operating system and the users. When a device (local or network) has been mounted, Linux will behave as if it is a part of the file system. That means users can access and manipulate directories and files of that location. TCP/IP (Transmission Control Protocol/Internet Protocol) \u00b6 TCP/IP - is the fundamental communication protocol suite used for network communication in Linux and the internet. - provides a reliable and standardized set of protocols that enable data transmission between devices. - is the backbone of network communication, letting the devices talk to each other and exchange data. TCP ensures reliable delivery of data and IP handles addressing and routing of data packets. UEFI (Unified Extensible Firmware Interface) \u00b6 UEFI is - a modern firmware interface - replaces the traditional BIOS (Basic Input/Output System) - provides advanced boot and system initialization capabilities - supports large disk sizes - offers additional security features. - can be used by Linux systems for booting and initialization of hardware. Virtualization \u00b6 When you do virtualization in Linux it means you are running (perhaps several) \u201cvirtual\u201d instances of OS\u2019es on a physical computer. Typical technologies for this in Linux are KVMs (Kernel-based Virtual Machines), Docker, Singularity, and similar. Virtualization does not just allow you to use one physical machine to run several virtual ones (with perhaps different OS\u2019es), but for instance also to run software/applications that would not run on the OS of the physical machine. Example: you need to run a Windows-only software on your machine that has Linux; you then create a virtual machine that has Windows installed and run your software. Docker (Singularity, Apptainer, etc) images are commonly used as an easy way of distributing a full environment with OS and installed software. Wifi \u00b6 Wifi (or Wi-Fi) is an abbreviation of \u201cWireless Fidelity\u201d and it is a networking technology allowing devices to connect to \u201cLANs\u201d (Local Area Networks) without neccessitating wired network connection. Linux supports a number of WiFi adapters for managing and configuring wireless network connections. Note Many of the entries on this list are fully or partially taken, with thanks, from https://www.coursera.org/collections/linux-terms http://www.miralishahidi.ir/resources/Linux Terminology Glossary.pdf Further inspiration and some material taken, with thanks, from https://www.ricmedia.com/tutorials/linux-for-beginners-a-comprehensive-guide-to-basic-concepts-and-terminology https://askubuntu.com/questions/506510/what-is-the-difference-between-terminal-console-shell-and-command-line/506628#506628","title":"Linux terminology"},{"location":"linux-terminology/#linux__terminology","text":"This section will give an overview of some of the most common terminology of Linux, as it may not be familiar to someone coming from i.e. Windows. It is, however, useful to know the meaning of some of the terms you will often see when searching for information about Linux or anything done on a Linux system. For a more detailed list of Linux terminology, there is a link to a Glossary of Linux Terms .","title":"Linux terminology"},{"location":"linux-terminology/#linux","text":"While we usually think of Linux as an operating system, that is not strictly true; Linux is a free and open-source kernel developed by Linus Torvalds in 1991.","title":"Linux"},{"location":"linux-terminology/#kernel","text":"\u2018Kernels\u2019 are at the core of every Operating System (OS). Note A kernel manages your system\u2019s hardware, as well as all the programs on your computer. When, for instance, you press a key on your keyboard or use your mouse to click a button on the screen, this information gets sent through the kernel. It will then communicate with the operating system, to use the data as input and to show the output using the hardware (in this case the monitor). Linux : the base Linux kernel is open-source. A large number of distributions (distros) use this core. They then modify it to lesser or greater extent, suiting their particular goals. The Linux kernel: - is the core component of the Linux OS - is open source and actively developed by a large community - manages hardware resources - handles communication between software and hardware - is in charge of - device drivers - process management - memory management - other low-level system operations","title":"Kernel"},{"location":"linux-terminology/#distributions__distros","text":"Note Different versions of Linux are called distributions or \u201cdistros\u201d. There are a large number of Linux distributions, as anyone can create their own Linux distro. It is thus important to check at least the most popular distros if you are considering to switch to another operating system. Some are easier to use than others. Examples of popular Linux distros are: Ubuntu, Debian, Fedora, CentOS, Slackware, Gentoo, Arch, Mint, and many others. Note Many distros can be downloaded and put on a bootable USB, so you can try them out before deciding. Any operating system that uses the Linux kernel is called a Linux distribution (\u201cdistro\u201d). The reason for that name comes from sharing , or distributing the Linux OS (usually for free). Aside from distributions, developers make customized versions of the various \u201cmainstream\u201d Linux distributions. These are called remixes , flavours, and spins . Often the differences are choices of packages, desktop environments, etc. There is no hard difference between calling the customized versions remixes, flavours, or spins - it is mainly a choice. A distro is a complete operating system, including - the Linux kernel - software packages - various tools and utilities The different spins/flavours of that distro could have - different package managers - desktop environments - various other features. Example: Ubuntu The distro Ubuntu has several flavors : Xubuntu, Lubuntu, Kubuntu, etc. each which has a different desktop environment. Example: \u201cFedora The distro Fedora uses the expression spins for its derivatives.","title":"Distributions (distros)"},{"location":"linux-terminology/#desktop__environments","text":"To make it easier for users to work on their computer, many operating systems have a desktop that offers a graphical interface manage the system. Windows and macOS are common examples. Linux also has (optional) desktop(s), but things are done a little different. Linux offers a great many desktops, which are called \u201cdesktop environments\u201d. The vast majority of those are available to install for free. Desktop environments (usually) come with a program called a \u201cwindow manager\u201d, as well as apps and widgets that, combined with the window manager, makes for a better user interface that can be further customized. Note Popular desktop environments are GNOME, KDE Plasma, XFCE, Pantheon, LXDE, and many more.","title":"Desktop environments"},{"location":"linux-terminology/#window__managers","text":"Window managers: - are programs controlling placement and movement of windows on your screen - usually work together with desktop environments - can also be used separately on your Linux machine - are lightweight and can offer better performance than desktop environments - do not ship with unnecessary apps and widget (you even have to install menu and compositor if you go with just a window manager) - can be complicated to set up for non-technical users, since you need to install everything extra yourself Note Some of the popular window managers are: i3wm, bspwm, awesome, Fluxbox KDE Plasma and GNOME desktops use the KWin and Mutter window managers \u201cunder the hood\u201d \u201cGNU Network Object Model Environment (GNOME)\u201d is a desktop environment used by several Linux distros. It is quite similar to the Windows desktop and can be a good choice if you are changing from that OS","title":"Window managers"},{"location":"linux-terminology/#commands","text":"The prompts that you type on the terminal are called \u201ccommands\u201d. The terminal is also commonly called the \u201ccommand line\u201d or the \u201ccommand line interface\u201d (CLI). There are several applications that can be used to access the command line, so it will vary how it looks, but it is usually a simple window (commonly white or green on black background or black on white background). Using commands on a command line interface is something many people find to be the most intimidating thing about Linux. However, while the command line is an integral part of using Linux, and some actions may be faster or more direct when done on the command line, most things can actually be done through a Graphical User Interface (GUI).","title":"Commands"},{"location":"linux-terminology/#command__line__interface__cli__terminal","text":"The terminal, console, or \u201ccommand line interface\u201d (often abbreviated \u201cCLI\u201d) is a text.based interface which is often the primary way to interact with Linux. The terminal is where you enter your \u201ccommands\u201d . It is usually very straightforward and simple, but you can also choose to use a terminal emulator which will give you a more user-friendly interface. It is a program that is used to control your operating system\u2019s \u201cshell\u201d . Briefly; a shell is a text-based (or graphical interface) through which the user interact with the desktop. Note The Linux terminal is similar to \u201cCommand Prompt\u201d on Windows. It is used by the \u201csuper user\u201d or \u201cadministrator\u201d to control and manage the system efficiently. It can be used to configure settings, for scripting, directly controlling the system, as well as giving various other commands to any program on the system. While other operating systems like Windows once regularly used something like a terminal, it is now more seldom used except for some administrative management. On Linux, however, the terminal is still very much used. This may surprise some, but there are several good reasons: The command line is fast: The CLI is usually much faster than using a GUI, and command-line programs will also start faster that graphical programs due to less overhead. Many programming tools use the command line: compilers, interpreters, debuggers all run on the command line. Yes, there are often a graphical IDE you can install, but that is just a wrapper for the command line program. The command line works everywhere: it is easy to use remotely through SSH, for installing and maintaining servers, you can use it without starting a graphical interface, which gives less overhead and makes it faster and more efficient You can script command line programs: this is a big advantage; you can avoid many repetitive operations when using a script Example: renaming, copying, or moving many files through a graphical file manager can be a hassle. On the command line you can script it. For instance, copying all your .dat files to a directory could be done like this: cp *.dat /mydir You can also use scripting for more complicated tasks. Some of the most commonly used scripting languages are the shell, perl, and Python.","title":"Command line interface (CLI), terminal"},{"location":"linux-terminology/#root__user","text":"All Linux operating systems have a built-in system of user roles, where each user has a specific role, with varying levels of permissions. Some of the common roles are: - user: nothing more, nothing less. The user can normally do what they want in their own home directory and perhaps a few other directories where they have been given permission to work. A user cannot install anything to the system outside of these directories where they have permission, and also cannot change most setup files (other than those affecting only themself). - root: The root user or root account has administrative priviliges; complete access to all configurations, commands, and files in the system. Other words for root is superuser or administrator , though root is the most common term on Linux. Note root refers to both the root directory and the root user . The root directory is the top level/parent directory containing all files and folders of the system. It is designated with a \u201c/\u201d, and this is how you can denote it in your commands.","title":"Root, user"},{"location":"linux-terminology/#package__manager","text":"On Linux, the programs you install are often referred to as \u201cpackages\u201d. Commonly, they are installed on the command line. A \u201cpackage manager\u201d is a tool that gives you a graphical interface to help you find new packages, install, update, and sometimes even configure them. On Linux, most apps are distributed as packages and are available in the official repositories of your distribution. You can also add third-party repositories with a package manager if you want access to even more packages. There are several different package managers available for the different Linux distros. These are some of the popular ones: - APT: used by Debian and Ubuntu-based distributions. - RPM: used by Fedora, CentOS, and RHEL. - pacman: used by Arch Linux and its derivatives. - yum/dnf: used by Red Hat-based distributions.","title":"Package manager"},{"location":"linux-terminology/#source__and__binary__packages","text":"Source packages: these contain the source code of a program: A user must manually compile and install it to run the software. Binary packages: these contain prebuilt and pre-compiled executables for the software.","title":"Source and binary packages"},{"location":"linux-terminology/#repositories","text":"Collections of packages and their metadata can be found in software repositories on remote servers. Most Linux distros has their own set of repositories or else they use the repositories of their parent distro.","title":"Repositories"},{"location":"linux-terminology/#open__source","text":"Wikipedia defines Open Source as: Source code that is made freely available for possible modification and redistribution. Products include permission to use the source code, design documents, or content of the product. The open-source model is a decentralized software development model that encourages open collaboration. A main principle of open-source software development is peer production, with products such as source code, blueprints, and documentation freely available to the public. The open-source movement in software began as a response to the limitations of proprietary code. Open source has played a significant role in the growth and popularity of Linux.","title":"Open Source"},{"location":"linux-terminology/#process","text":"Each program you start on your system will run a number of processes in the background. A process is the instance of a running program which does the computation. It is the allocation of memory for the program as well as a thread for execution. Examples that launches a process or a set of processes You start a program, maybe a game You start your web browser You open a new tab in your web browser You run a command in a terminal All programs depends on processes to run and produce output. Note In Linux a process refers to a running instance of a program or command. Each process has a unique process ID (PID) Each process also has associated system resources (memory, file descriptors, etc) There are robust process management capabilities. Users can start, terminate, monitor processes, control their execution, manage system resources","title":"Process"},{"location":"linux-terminology/#shells","text":"A Shell is a command-line interpreter which provides an interface for users to interact with the operating system. There are several different shells: Bash (Bourne Again Shell), C Shell, Korn Shell, and Zsh, etc. Shells allow users to: - execute commands - run scripts - perform system operations Shells provide features like: - command history - input/output redirection - variables - control structures The two main \u201cfamilies\u201d of shells are C-shell and Bourne shell. csh : The C shell (csh or the improved version, tcsh) is a Unix shell created by Bill Joy while he was a graduate student at University of California, Berkeley in the late 1970s. The C shell is a command processor which is typically run in a text window, allowing the user to type and execute commands. The C shell can also read commands from a file, called a script. The style of the shell script language resembles C. tcsh : a Unix shell based on and backward compatible with the C shell (csh). It is essentially the C shell with programmable command-line completion, command-line editing, and a few other features. Unlike the other common shells, functions cannot be defined in a tcsh script and the user must use aliases instead (as in csh). sh : The Bourne shell (sh) is a shell command-line interpreter for computer operating systems, developed by Stephen Bourne at Bell Labs. It is used as an interactive command interpreter, but was also intended as a scripting language and contains most of the features that are commonly considered to produce structured programs. bash : (Bourne Again Shell). It provides a command-line interface for interacting with the operating system and executing commands. Bash offers features like command history, tab completion, scripting capabilities, and extensive support for shell scripting, making it a powerful tool for system administration and automation. ksh : KornShell. It is a Unix shell which was developed by David Korn at Bell Labs in the early 1980s. KornShell is backward-compatible with the Bourne shell and includes many features of the C shell, inspired by the requests of Bell Labs users. zsh : The Z shell (Zsh) is a Unix shell that can be used as an interactive login shell and as a command interpreter for shell scripting. Zsh is an extended Bourne shell with many improvements, including some features of Bash, ksh, and tcsh. Bash and tcsh are probably the most \u201cpopular\u201d of the shells.","title":"Shells"},{"location":"linux-terminology/#shell__scripting","text":"A shell script is a computer program designed to be run by a Unix shell, a command-line interpreter. When you write several Linux commands and place them together in a single file, the resulting file is called a \u201cshell script.\u201d Shell scripting is the process of writing scripts using Linux commands, which are then interpreted by the shell installed on your system. Note The Windows equivalent to shell scripts are \u201cbatch scripts\u201d. Do NOT confuse these with the batch scripts used by batch systems! The most popular shell scripting language is Bash scripting - this means writing and executing scripts using the Bash shell.","title":"Shell Scripting"},{"location":"linux-terminology/#file__system","text":"A file system provides a data storage service that allows applications to share mass storage. Without a file system, applications could access the storage in incompatible ways that lead to resource contention, data corruption and data loss. A File System is a method or structure the operating system uses to organize and store files on disk or other storage devices. Note Linux supports several different file systems, including ext4, XFS, Btrfs, and NTFS. These file systems has different features, performance characteristics, and compatibility with other operating systems.","title":"File system"},{"location":"linux-terminology/#gnu","text":"GNU is an extensive collection of free software, which can be used as an operating system or can be used in parts with other operating systems. The use of the completed GNU tools led to the family of operating systems popularly known as Linux. Most of GNU is licensed under the GNU Project\u2019s own General Public License.i GNU is a recursive acronym for \u201cGNU\u2019s Not Unix\u201d. The Linux kernel is licensed under GNU\u2019s GPL (General Public License) and is thus known as GNU/Linux. Any operating system developed using the open-source GNU tools and the Linux kernel falls under the category of Linux distributions.","title":"GNU"},{"location":"linux-terminology/#advanced","text":"There are many other terms which you may come across when reading about Linux. These are a few of them.","title":"Advanced"},{"location":"linux-terminology/#bootloader__grub","text":"Note A bootloader is a program responsible for booting your computer. When a computer is turned off, its software - including the operating systems, application code, and data - remains stored on non-volatile memory. The computer normally does not have an operating system or its loader in random-access memory (RAM) when it is powered on. First the computer executes a small program (the boot loader) stored in read-only memory (ROM) along with some needed data, to initialize RAM, to access the nonvolatile device (storage system like HDD) or devices from which the operating system programs and data can be loaded into RAM. GRUB is one of the most used bootloaders, including when dual-booting Windows with Linux. Other examples include LILO, BURG, and Syslinux.","title":"Bootloader, grub"},{"location":"linux-terminology/#encryption","text":"Encryption scrambles data into a secure and unreadable form so it can only be accessed by authorized parties. Linux provides encryption to secure data, both during transmission and on the system. This is done through encrypted file systems, disk encryption, and network encryption.","title":"Encryption"},{"location":"linux-terminology/#ip__address__internet__protocol__address","text":"(Much of this section was taken from Wikipedia) An Internet Protocol address (IP address) is a unique numerical label that is assigned to every device that is connected to a network. IP addresses in Linux are used for: - network configuration - routing - device communication IP addresses can either be assigned manually (static IP address) or dynamically (DHCP). They are crucially important in establishing network connections and enabling internet connectivity. Two versions of the Internet Protocol are in common use on the Internet today: - The original version of the Internet Protocol (deployed in 1983 in the ARPANET) is Internet Protocol version 4 (IPv4). - An IPv4 address has a size of 32 bits, which limits the address space to 4294967296 (232) addresses. Some addresses are reserved for special purposes such as private networks (\u224818 million addresses) and multicast addressing (\u2248270 million addresses). - IPv4 addresses are usually represented in dot-decimal notation, consisting of four decimal numbers, each ranging from 0 to 255, separated by dots, e.g., 192.0.2.1. Each part represents a group of 8 bits (an octet) of the address. - The Internet Protocol Version 6 (IPv6) was developed in 1995. IPv6 technology was in various testing stages until the mid-2000s when commercial production deployment commenced. - In IPv6, the address size was increased from 32 bits in IPv4 to 128 bits, thus providing up to 2128 (approximately 3.403\u00d71038) addresses. This is deemed sufficient for the foreseeable future.","title":"IP Address (Internet Protocol Address)"},{"location":"linux-terminology/#kernel__panic","text":"Kernel Panic is a critical error condition in the Linux kernel. When this happens it cannot continue operating safely. The reason for it happening is usually severe software or hardware issues, such as: a corrupted kernel, hardware failure, or incompatible drivers. The system halts when there is a kernel panic. An error message is displayed, and a manual reboot needs to be done. Kernel panics happen quite rarely, but are something that gives cause for concernt and needs to be investigated so the cause can be found and resolved.","title":"Kernel Panic"},{"location":"linux-terminology/#mount","text":"Mounting means to attach a file system to a specific directory location in the Linux file hierarchy. This causes the contents of the file system to become accessible to the operating system and the users. When a device (local or network) has been mounted, Linux will behave as if it is a part of the file system. That means users can access and manipulate directories and files of that location.","title":"Mount"},{"location":"linux-terminology/#tcpip__transmission__control__protocolinternet__protocol","text":"TCP/IP - is the fundamental communication protocol suite used for network communication in Linux and the internet. - provides a reliable and standardized set of protocols that enable data transmission between devices. - is the backbone of network communication, letting the devices talk to each other and exchange data. TCP ensures reliable delivery of data and IP handles addressing and routing of data packets.","title":"TCP/IP (Transmission Control Protocol/Internet Protocol)"},{"location":"linux-terminology/#uefi__unified__extensible__firmware__interface","text":"UEFI is - a modern firmware interface - replaces the traditional BIOS (Basic Input/Output System) - provides advanced boot and system initialization capabilities - supports large disk sizes - offers additional security features. - can be used by Linux systems for booting and initialization of hardware.","title":"UEFI (Unified Extensible Firmware Interface)"},{"location":"linux-terminology/#virtualization","text":"When you do virtualization in Linux it means you are running (perhaps several) \u201cvirtual\u201d instances of OS\u2019es on a physical computer. Typical technologies for this in Linux are KVMs (Kernel-based Virtual Machines), Docker, Singularity, and similar. Virtualization does not just allow you to use one physical machine to run several virtual ones (with perhaps different OS\u2019es), but for instance also to run software/applications that would not run on the OS of the physical machine. Example: you need to run a Windows-only software on your machine that has Linux; you then create a virtual machine that has Windows installed and run your software. Docker (Singularity, Apptainer, etc) images are commonly used as an easy way of distributing a full environment with OS and installed software.","title":"Virtualization"},{"location":"linux-terminology/#wifi","text":"Wifi (or Wi-Fi) is an abbreviation of \u201cWireless Fidelity\u201d and it is a networking technology allowing devices to connect to \u201cLANs\u201d (Local Area Networks) without neccessitating wired network connection. Linux supports a number of WiFi adapters for managing and configuring wireless network connections. Note Many of the entries on this list are fully or partially taken, with thanks, from https://www.coursera.org/collections/linux-terms http://www.miralishahidi.ir/resources/Linux Terminology Glossary.pdf Further inspiration and some material taken, with thanks, from https://www.ricmedia.com/tutorials/linux-for-beginners-a-comprehensive-guide-to-basic-concepts-and-terminology https://askubuntu.com/questions/506510/what-is-the-difference-between-terminal-console-shell-and-command-line/506628#506628","title":"Wifi"},{"location":"linux-terms/","text":"More Linux terminology \u00b6 This section lists some more of the most common terminology of Linux. For a more detailed list of Linux terminology, there is a link to a Glossary of Linux Terms . Process \u00b6 Each program you start on your system will run a number of processes in the background. A process is the instance of a running program which does the computation. It is the allocation of memory for the program as well as a thread for execution. Examples that launches a process or a set of processes You start a program, maybe a game You start your web browser You open a new tab in your web browser You run a command in a terminal All programs depends on processes to run and produce output. Note In Linux a process refers to a running instance of a program or command. Each process has a unique process ID (PID) Each process also has associated system resources (memory, file descriptors, etc) There are robust process management capabilities. Users can start, terminate, monitor processes, control their execution, manage system resources Shells \u00b6 A Shell is a command-line interpreter which provides an interface for users to interact with the operating system. There are several different shells: Bash (Bourne Again Shell), C Shell, Korn Shell, and Zsh, etc. Shells allow users to: - execute commands - run scripts - perform system operations Shells provide features like: - command history - input/output redirection - variables - control structures The two main \u201cfamilies\u201d of shells are C-shell and Bourne shell. csh : The C shell (csh or the improved version, tcsh) is a Unix shell created by Bill Joy while he was a graduate student at University of California, Berkeley in the late 1970s. The C shell is a command processor which is typically run in a text window, allowing the user to type and execute commands. The C shell can also read commands from a file, called a script. The style of the shell script language resembles C. tcsh : a Unix shell based on and backward compatible with the C shell (csh). It is essentially the C shell with programmable command-line completion, command-line editing, and a few other features. Unlike the other common shells, functions cannot be defined in a tcsh script and the user must use aliases instead (as in csh). sh : The Bourne shell (sh) is a shell command-line interpreter for computer operating systems, developed by Stephen Bourne at Bell Labs. It is used as an interactive command interpreter, but was also intended as a scripting language and contains most of the features that are commonly considered to produce structured programs. bash : (Bourne Again Shell). It provides a command-line interface for interacting with the operating system and executing commands. Bash offers features like command history, tab completion, scripting capabilities, and extensive support for shell scripting, making it a powerful tool for system administration and automation. ksh : KornShell. It is a Unix shell which was developed by David Korn at Bell Labs in the early 1980s. KornShell is backward-compatible with the Bourne shell and includes many features of the C shell, inspired by the requests of Bell Labs users. zsh : The Z shell (Zsh) is a Unix shell that can be used as an interactive login shell and as a command interpreter for shell scripting. Zsh is an extended Bourne shell with many improvements, including some features of Bash, ksh, and tcsh. Bash and tcsh are probably the most \u201cpopular\u201d of the shells. Shell Scripting \u00b6 A shell script is a computer program designed to be run by a Unix shell, a command-line interpreter. When you write several Linux commands and place them together in a single file, the resulting file is called a \u201cshell script.\u201d Shell scripting is the process of writing scripts using Linux commands, which are then interpreted by the shell installed on your system. Note The Windows equivalent to shell scripts are \u201cbatch scripts\u201d. Do NOT confuse these with the batch scripts used by batch systems! The most popular shell scripting language is Bash scripting - this means writing and executing scripts using the Bash shell. File system \u00b6 A file system provides a data storage service that allows applications to share mass storage. Without a file system, applications could access the storage in incompatible ways that lead to resource contention, data corruption and data loss. A File System is a method or structure the operating system uses to organize and store files on disk or other storage devices. Note Linux supports several different file systems, including ext4, XFS, Btrfs, and NTFS. These file systems has different features, performance characteristics, and compatibility with other operating systems. GNU \u00b6 GNU is an extensive collection of free software, which can be used as an operating system or can be used in parts with other operating systems. The use of the completed GNU tools led to the family of operating systems popularly known as Linux. Most of GNU is licensed under the GNU Project\u2019s own General Public License.i GNU is a recursive acronym for \u201cGNU\u2019s Not Unix\u201d. The Linux kernel is licensed under GNU\u2019s GPL (General Public License) and is thus known as GNU/Linux. Any operating system developed using the open-source GNU tools and the Linux kernel falls under the category of Linux distributions. Advanced \u00b6 There are many other terms which you may come across when reading about Linux. These are a few of them. Bootloader, grub \u00b6 Note A bootloader is a program responsible for booting your computer. When a computer is turned off, its software - including the operating systems, application code, and data - remains stored on non-volatile memory. The computer normally does not have an operating system or its loader in random-access memory (RAM) when it is powered on. First the computer executes a small program (the boot loader) stored in read-only memory (ROM) along with some needed data, to initialize RAM, to access the nonvolatile device (storage system like HDD) or devices from which the operating system programs and data can be loaded into RAM. GRUB is one of the most used bootloaders, including when dual-booting Windows with Linux. Other examples include LILO, BURG, and Syslinux. Encryption \u00b6 Encryption scrambles data into a secure and unreadable form so it can only be accessed by authorized parties. Linux provides encryption to secure data, both during transmission and on the system. This is done through encrypted file systems, disk encryption, and network encryption. IP Address (Internet Protocol Address) \u00b6 (Much of this section was taken from Wikipedia) An Internet Protocol address (IP address) is a unique numerical label that is assigned to every device that is connected to a network. IP addresses in Linux are used for: - network configuration - routing - device communication IP addresses can either be assigned manually (static IP address) or dynamically (DHCP). They are crucially important in establishing network connections and enabling internet connectivity. Two versions of the Internet Protocol are in common use on the Internet today: - The original version of the Internet Protocol (deployed in 1983 in the ARPANET) is Internet Protocol version 4 (IPv4). - An IPv4 address has a size of 32 bits, which limits the address space to 4294967296 (232) addresses. Some addresses are reserved for special purposes such as private networks (\u224818 million addresses) and multicast addressing (\u2248270 million addresses). - IPv4 addresses are usually represented in dot-decimal notation, consisting of four decimal numbers, each ranging from 0 to 255, separated by dots, e.g., 192.0.2.1. Each part represents a group of 8 bits (an octet) of the address. - The Internet Protocol Version 6 (IPv6) was developed in 1995. IPv6 technology was in various testing stages until the mid-2000s when commercial production deployment commenced. - In IPv6, the address size was increased from 32 bits in IPv4 to 128 bits, thus providing up to 2128 (approximately 3.403\u00d71038) addresses. This is deemed sufficient for the foreseeable future. Kernel Panic \u00b6 Kernel Panic is a critical error condition in the Linux kernel. When this happens it cannot continue operating safely. The reason for it happening is usually severe software or hardware issues, such as: a corrupted kernel, hardware failure, or incompatible drivers. The system halts when there is a kernel panic. An error message is displayed, and a manual reboot needs to be done. Kernel panics happen quite rarely, but are something that gives cause for concernt and needs to be investigated so the cause can be found and resolved. Mount \u00b6 Mounting means to attach a file system to a specific directory location in the Linux file hierarchy. This causes the contents of the file system to become accessible to the operating system and the users. When a device (local or network) has been mounted, Linux will behave as if it is a part of the file system. That means users can access and manipulate directories and files of that location. TCP/IP (Transmission Control Protocol/Internet Protocol) \u00b6 TCP/IP - is the fundamental communication protocol suite used for network communication in Linux and the internet. - provides a reliable and standardized set of protocols that enable data transmission between devices. - is the backbone of network communication, letting the devices talk to each other and exchange data. TCP ensures reliable delivery of data and IP handles addressing and routing of data packets. UEFI (Unified Extensible Firmware Interface) \u00b6 UEFI is - a modern firmware interface - replaces the traditional BIOS (Basic Input/Output System) - provides advanced boot and system initialization capabilities - supports large disk sizes - offers additional security features. - can be used by Linux systems for booting and initialization of hardware.","title":"More Linux terminology"},{"location":"linux-terms/#more__linux__terminology","text":"This section lists some more of the most common terminology of Linux. For a more detailed list of Linux terminology, there is a link to a Glossary of Linux Terms .","title":"More Linux terminology"},{"location":"linux-terms/#process","text":"Each program you start on your system will run a number of processes in the background. A process is the instance of a running program which does the computation. It is the allocation of memory for the program as well as a thread for execution. Examples that launches a process or a set of processes You start a program, maybe a game You start your web browser You open a new tab in your web browser You run a command in a terminal All programs depends on processes to run and produce output. Note In Linux a process refers to a running instance of a program or command. Each process has a unique process ID (PID) Each process also has associated system resources (memory, file descriptors, etc) There are robust process management capabilities. Users can start, terminate, monitor processes, control their execution, manage system resources","title":"Process"},{"location":"linux-terms/#shells","text":"A Shell is a command-line interpreter which provides an interface for users to interact with the operating system. There are several different shells: Bash (Bourne Again Shell), C Shell, Korn Shell, and Zsh, etc. Shells allow users to: - execute commands - run scripts - perform system operations Shells provide features like: - command history - input/output redirection - variables - control structures The two main \u201cfamilies\u201d of shells are C-shell and Bourne shell. csh : The C shell (csh or the improved version, tcsh) is a Unix shell created by Bill Joy while he was a graduate student at University of California, Berkeley in the late 1970s. The C shell is a command processor which is typically run in a text window, allowing the user to type and execute commands. The C shell can also read commands from a file, called a script. The style of the shell script language resembles C. tcsh : a Unix shell based on and backward compatible with the C shell (csh). It is essentially the C shell with programmable command-line completion, command-line editing, and a few other features. Unlike the other common shells, functions cannot be defined in a tcsh script and the user must use aliases instead (as in csh). sh : The Bourne shell (sh) is a shell command-line interpreter for computer operating systems, developed by Stephen Bourne at Bell Labs. It is used as an interactive command interpreter, but was also intended as a scripting language and contains most of the features that are commonly considered to produce structured programs. bash : (Bourne Again Shell). It provides a command-line interface for interacting with the operating system and executing commands. Bash offers features like command history, tab completion, scripting capabilities, and extensive support for shell scripting, making it a powerful tool for system administration and automation. ksh : KornShell. It is a Unix shell which was developed by David Korn at Bell Labs in the early 1980s. KornShell is backward-compatible with the Bourne shell and includes many features of the C shell, inspired by the requests of Bell Labs users. zsh : The Z shell (Zsh) is a Unix shell that can be used as an interactive login shell and as a command interpreter for shell scripting. Zsh is an extended Bourne shell with many improvements, including some features of Bash, ksh, and tcsh. Bash and tcsh are probably the most \u201cpopular\u201d of the shells.","title":"Shells"},{"location":"linux-terms/#shell__scripting","text":"A shell script is a computer program designed to be run by a Unix shell, a command-line interpreter. When you write several Linux commands and place them together in a single file, the resulting file is called a \u201cshell script.\u201d Shell scripting is the process of writing scripts using Linux commands, which are then interpreted by the shell installed on your system. Note The Windows equivalent to shell scripts are \u201cbatch scripts\u201d. Do NOT confuse these with the batch scripts used by batch systems! The most popular shell scripting language is Bash scripting - this means writing and executing scripts using the Bash shell.","title":"Shell Scripting"},{"location":"linux-terms/#file__system","text":"A file system provides a data storage service that allows applications to share mass storage. Without a file system, applications could access the storage in incompatible ways that lead to resource contention, data corruption and data loss. A File System is a method or structure the operating system uses to organize and store files on disk or other storage devices. Note Linux supports several different file systems, including ext4, XFS, Btrfs, and NTFS. These file systems has different features, performance characteristics, and compatibility with other operating systems.","title":"File system"},{"location":"linux-terms/#gnu","text":"GNU is an extensive collection of free software, which can be used as an operating system or can be used in parts with other operating systems. The use of the completed GNU tools led to the family of operating systems popularly known as Linux. Most of GNU is licensed under the GNU Project\u2019s own General Public License.i GNU is a recursive acronym for \u201cGNU\u2019s Not Unix\u201d. The Linux kernel is licensed under GNU\u2019s GPL (General Public License) and is thus known as GNU/Linux. Any operating system developed using the open-source GNU tools and the Linux kernel falls under the category of Linux distributions.","title":"GNU"},{"location":"linux-terms/#advanced","text":"There are many other terms which you may come across when reading about Linux. These are a few of them.","title":"Advanced"},{"location":"linux-terms/#bootloader__grub","text":"Note A bootloader is a program responsible for booting your computer. When a computer is turned off, its software - including the operating systems, application code, and data - remains stored on non-volatile memory. The computer normally does not have an operating system or its loader in random-access memory (RAM) when it is powered on. First the computer executes a small program (the boot loader) stored in read-only memory (ROM) along with some needed data, to initialize RAM, to access the nonvolatile device (storage system like HDD) or devices from which the operating system programs and data can be loaded into RAM. GRUB is one of the most used bootloaders, including when dual-booting Windows with Linux. Other examples include LILO, BURG, and Syslinux.","title":"Bootloader, grub"},{"location":"linux-terms/#encryption","text":"Encryption scrambles data into a secure and unreadable form so it can only be accessed by authorized parties. Linux provides encryption to secure data, both during transmission and on the system. This is done through encrypted file systems, disk encryption, and network encryption.","title":"Encryption"},{"location":"linux-terms/#ip__address__internet__protocol__address","text":"(Much of this section was taken from Wikipedia) An Internet Protocol address (IP address) is a unique numerical label that is assigned to every device that is connected to a network. IP addresses in Linux are used for: - network configuration - routing - device communication IP addresses can either be assigned manually (static IP address) or dynamically (DHCP). They are crucially important in establishing network connections and enabling internet connectivity. Two versions of the Internet Protocol are in common use on the Internet today: - The original version of the Internet Protocol (deployed in 1983 in the ARPANET) is Internet Protocol version 4 (IPv4). - An IPv4 address has a size of 32 bits, which limits the address space to 4294967296 (232) addresses. Some addresses are reserved for special purposes such as private networks (\u224818 million addresses) and multicast addressing (\u2248270 million addresses). - IPv4 addresses are usually represented in dot-decimal notation, consisting of four decimal numbers, each ranging from 0 to 255, separated by dots, e.g., 192.0.2.1. Each part represents a group of 8 bits (an octet) of the address. - The Internet Protocol Version 6 (IPv6) was developed in 1995. IPv6 technology was in various testing stages until the mid-2000s when commercial production deployment commenced. - In IPv6, the address size was increased from 32 bits in IPv4 to 128 bits, thus providing up to 2128 (approximately 3.403\u00d71038) addresses. This is deemed sufficient for the foreseeable future.","title":"IP Address (Internet Protocol Address)"},{"location":"linux-terms/#kernel__panic","text":"Kernel Panic is a critical error condition in the Linux kernel. When this happens it cannot continue operating safely. The reason for it happening is usually severe software or hardware issues, such as: a corrupted kernel, hardware failure, or incompatible drivers. The system halts when there is a kernel panic. An error message is displayed, and a manual reboot needs to be done. Kernel panics happen quite rarely, but are something that gives cause for concernt and needs to be investigated so the cause can be found and resolved.","title":"Kernel Panic"},{"location":"linux-terms/#mount","text":"Mounting means to attach a file system to a specific directory location in the Linux file hierarchy. This causes the contents of the file system to become accessible to the operating system and the users. When a device (local or network) has been mounted, Linux will behave as if it is a part of the file system. That means users can access and manipulate directories and files of that location.","title":"Mount"},{"location":"linux-terms/#tcpip__transmission__control__protocolinternet__protocol","text":"TCP/IP - is the fundamental communication protocol suite used for network communication in Linux and the internet. - provides a reliable and standardized set of protocols that enable data transmission between devices. - is the backbone of network communication, letting the devices talk to each other and exchange data. TCP ensures reliable delivery of data and IP handles addressing and routing of data packets.","title":"TCP/IP (Transmission Control Protocol/Internet Protocol)"},{"location":"linux-terms/#uefi__unified__extensible__firmware__interface","text":"UEFI is - a modern firmware interface - replaces the traditional BIOS (Basic Input/Output System) - provides advanced boot and system initialization capabilities - supports large disk sizes - offers additional security features. - can be used by Linux systems for booting and initialization of hardware.","title":"UEFI (Unified Extensible Firmware Interface)"},{"location":"linux/","text":"Linux terminology \u00b6 This section will give an overview of some of the most common terminology of Linux, as it may not be familiar to someone coming from i.e. Windows. It is, however, useful to know the meaning of some of the terms you will often see when searching for information about Linux or anything done on a Linux system. For a more detailed list of Linux terminology, there is a link to a Glossary of Linux Terms . Linux \u00b6 While we usually think of Linux as an operating system, that is not strictly true; Linux is a free and open-source kernel developed by Linus Torvalds in 1991. Kernel \u00b6 \u2018Kernels\u2019 are at the core of every Operating System (OS). Note A kernel manages your system\u2019s hardware, as well as all the programs on your computer. When, for instance, you press a key on your keyboard or use your mouse to click a button on the screen, this information gets sent through the kernel. It will then communicate with the operating system, to use the data as input and to show the output using the hardware (in this case the monitor). Linux : the base Linux kernel is open-source. A large number of distributions (distros) use this core. They then modify it to lesser or greater extent, suiting their particular goals. The Linux kernel: - is the core component of the Linux OS - is open source and actively developed by a large community - manages hardware resources - handles communication between software and hardware - is in charge of - device drivers - process management - memory management - other low-level system operations Distributions (distros) \u00b6 Note Different versions of Linux are called distributions or \u201cdistros\u201d. There are a large number of Linux distributions, as anyone can create their own Linux distro. It is thus important to check at least the most popular distros if you are considering to switch to another operating system. Some are easier to use than others. Examples of popular Linux distros are: Ubuntu, Debian, Fedora, CentOS, Slackware, Gentoo, Arch, Mint, and many others. Note Many distros can be downloaded and put on a bootable USB, so you can try them out before deciding. Any operating system that uses the Linux kernel is called a Linux distribution (\u201cdistro\u201d). The reason for that name comes from sharing , or distributing the Linux OS (usually for free). Aside from distributions, developers make customized versions of the various \u201cmainstream\u201d Linux distributions. These are called remixes , flavours, and spins . Often the differences are choices of packages, desktop environments, etc. There is no hard difference between calling the customized versions remixes, flavours, or spins - it is mainly a choice. A distro is a complete operating system, including - the Linux kernel - software packages - various tools and utilities The different spins/flavours of that distro could have - different package managers - desktop environments - various other features. Example: Ubuntu The distro Ubuntu has several flavors : Xubuntu, Lubuntu, Kubuntu, etc. each which has a different desktop environment. Example: \u201cFedora The distro Fedora uses the expression spins for its derivatives. Desktop environments \u00b6 To make it easier for users to work on their computer, many operating systems have a desktop that offers a graphical interface manage the system. Windows and macOS are common examples. Linux also has (optional) desktop(s), but things are done a little different. Linux offers a great many desktops, which are called \u201cdesktop environments\u201d. The vast majority of those are available to install for free. Desktop environments (usually) come with a program called a \u201cwindow manager\u201d, as well as apps and widgets that, combined with the window manager, makes for a better user interface that can be further customized. Note Popular desktop environments are GNOME, KDE Plasma, XFCE, Pantheon, LXDE, and many more. Window managers \u00b6 Window managers: - are programs controlling placement and movement of windows on your screen - usually work together with desktop environments - can also be used separately on your Linux machine - are lightweight and can offer better performance than desktop environments - do not ship with unnecessary apps and widget (you even have to install menu and compositor if you go with just a window manager) - can be complicated to set up for non-technical users, since you need to install everything extra yourself Note Some of the popular window managers are: i3wm, bspwm, awesome, Fluxbox KDE Plasma and GNOME desktops use the KWin and Mutter window managers \u201cunder the hood\u201d \u201cGNU Network Object Model Environment (GNOME)\u201d is a desktop environment used by several Linux distros. It is quite similar to the Windows desktop and can be a good choice if you are changing from that OS Commands \u00b6 The prompts that you type on the terminal are called \u201ccommands\u201d. The terminal is also commonly called the \u201ccommand line\u201d or the \u201ccommand line interface\u201d (CLI). There are several applications that can be used to access the command line, so it will vary how it looks, but it is usually a simple window (commonly white or green on black background or black on white background). Using commands on a command line interface is something many people find to be the most intimidating thing about Linux. However, while the command line is an integral part of using Linux, and some actions may be faster or more direct when done on the command line, most things can actually be done through a Graphical User Interface (GUI). Command line interface (CLI), terminal \u00b6 The terminal, console, or \u201ccommand line interface\u201d (often abbreviated \u201cCLI\u201d) is a text.based interface which is often the primary way to interact with Linux. The terminal is where you enter your \u201ccommands\u201d . It is usually very straightforward and simple, but you can also choose to use a terminal emulator which will give you a more user-friendly interface. It is a program that is used to control your operating system\u2019s \u201cshell\u201d . Briefly; a shell is a text-based (or graphical interface) through which the user interact with the desktop. Note The Linux terminal is similar to \u201cCommand Prompt\u201d on Windows. It is used by the \u201csuper user\u201d or \u201cadministrator\u201d to control and manage the system efficiently. It can be used to configure settings, for scripting, directly controlling the system, as well as giving various other commands to any program on the system. While other operating systems like Windows once regularly used something like a terminal, it is now more seldom used except for some administrative management. On Linux, however, the terminal is still very much used. This may surprise some, but there are several good reasons: The command line is fast: The CLI is usually much faster than using a GUI, and command-line programs will also start faster that graphical programs due to less overhead. Many programming tools use the command line: compilers, interpreters, debuggers all run on the command line. Yes, there are often a graphical IDE you can install, but that is just a wrapper for the command line program. The command line works everywhere: it is easy to use remotely through SSH, for installing and maintaining servers, you can use it without starting a graphical interface, which gives less overhead and makes it faster and more efficient You can script command line programs: this is a big advantage; you can avoid many repetitive operations when using a script Example: renaming, copying, or moving many files through a graphical file manager can be a hassle. On the command line you can script it. For instance, copying all your .dat files to a directory could be done like this: cp *.dat /mydir You can also use scripting for more complicated tasks. Some of the most commonly used scripting languages are the shell, perl, and Python. Root, user \u00b6 All Linux operating systems have a built-in system of user roles, where each user has a specific role, with varying levels of permissions. Some of the common roles are: - user: nothing more, nothing less. The user can normally do what they want in their own home directory and perhaps a few other directories where they have been given permission to work. A user cannot install anything to the system outside of these directories where they have permission, and also cannot change most setup files (other than those affecting only themself). - root: The root user or root account has administrative priviliges; complete access to all configurations, commands, and files in the system. Other words for root is superuser or administrator , though root is the most common term on Linux. Note root refers to both the root directory and the root user . The root directory is the top level/parent directory containing all files and folders of the system. It is designated with a \u201c/\u201d, and this is how you can denote it in your commands. Package manager \u00b6 On Linux, the programs you install are often referred to as \u201cpackages\u201d. Commonly, they are installed on the command line. A \u201cpackage manager\u201d is a tool that gives you a graphical interface to help you find new packages, install, update, and sometimes even configure them. On Linux, most apps are distributed as packages and are available in the official repositories of your distribution. You can also add third-party repositories with a package manager if you want access to even more packages. There are several different package managers available for the different Linux distros. These are some of the popular ones: - APT: used by Debian and Ubuntu-based distributions. - RPM: used by Fedora, CentOS, and RHEL. - pacman: used by Arch Linux and its derivatives. - yum/dnf: used by Red Hat-based distributions. Source and binary packages \u00b6 Source packages: these contain the source code of a program: A user must manually compile and install it to run the software. Binary packages: these contain prebuilt and pre-compiled executables for the software. Repositories \u00b6 Collections of packages and their metadata can be found in software repositories on remote servers. Most Linux distros has their own set of repositories or else they use the repositories of their parent distro. Open Source \u00b6 Wikipedia defines Open Source as: Source code that is made freely available for possible modification and redistribution. Products include permission to use the source code, design documents, or content of the product. The open-source model is a decentralized software development model that encourages open collaboration. A main principle of open-source software development is peer production, with products such as source code, blueprints, and documentation freely available to the public. The open-source movement in software began as a response to the limitations of proprietary code. Open source has played a significant role in the growth and popularity of Linux.","title":"Linux terminology"},{"location":"linux/#linux__terminology","text":"This section will give an overview of some of the most common terminology of Linux, as it may not be familiar to someone coming from i.e. Windows. It is, however, useful to know the meaning of some of the terms you will often see when searching for information about Linux or anything done on a Linux system. For a more detailed list of Linux terminology, there is a link to a Glossary of Linux Terms .","title":"Linux terminology"},{"location":"linux/#linux","text":"While we usually think of Linux as an operating system, that is not strictly true; Linux is a free and open-source kernel developed by Linus Torvalds in 1991.","title":"Linux"},{"location":"linux/#kernel","text":"\u2018Kernels\u2019 are at the core of every Operating System (OS). Note A kernel manages your system\u2019s hardware, as well as all the programs on your computer. When, for instance, you press a key on your keyboard or use your mouse to click a button on the screen, this information gets sent through the kernel. It will then communicate with the operating system, to use the data as input and to show the output using the hardware (in this case the monitor). Linux : the base Linux kernel is open-source. A large number of distributions (distros) use this core. They then modify it to lesser or greater extent, suiting their particular goals. The Linux kernel: - is the core component of the Linux OS - is open source and actively developed by a large community - manages hardware resources - handles communication between software and hardware - is in charge of - device drivers - process management - memory management - other low-level system operations","title":"Kernel"},{"location":"linux/#distributions__distros","text":"Note Different versions of Linux are called distributions or \u201cdistros\u201d. There are a large number of Linux distributions, as anyone can create their own Linux distro. It is thus important to check at least the most popular distros if you are considering to switch to another operating system. Some are easier to use than others. Examples of popular Linux distros are: Ubuntu, Debian, Fedora, CentOS, Slackware, Gentoo, Arch, Mint, and many others. Note Many distros can be downloaded and put on a bootable USB, so you can try them out before deciding. Any operating system that uses the Linux kernel is called a Linux distribution (\u201cdistro\u201d). The reason for that name comes from sharing , or distributing the Linux OS (usually for free). Aside from distributions, developers make customized versions of the various \u201cmainstream\u201d Linux distributions. These are called remixes , flavours, and spins . Often the differences are choices of packages, desktop environments, etc. There is no hard difference between calling the customized versions remixes, flavours, or spins - it is mainly a choice. A distro is a complete operating system, including - the Linux kernel - software packages - various tools and utilities The different spins/flavours of that distro could have - different package managers - desktop environments - various other features. Example: Ubuntu The distro Ubuntu has several flavors : Xubuntu, Lubuntu, Kubuntu, etc. each which has a different desktop environment. Example: \u201cFedora The distro Fedora uses the expression spins for its derivatives.","title":"Distributions (distros)"},{"location":"linux/#desktop__environments","text":"To make it easier for users to work on their computer, many operating systems have a desktop that offers a graphical interface manage the system. Windows and macOS are common examples. Linux also has (optional) desktop(s), but things are done a little different. Linux offers a great many desktops, which are called \u201cdesktop environments\u201d. The vast majority of those are available to install for free. Desktop environments (usually) come with a program called a \u201cwindow manager\u201d, as well as apps and widgets that, combined with the window manager, makes for a better user interface that can be further customized. Note Popular desktop environments are GNOME, KDE Plasma, XFCE, Pantheon, LXDE, and many more.","title":"Desktop environments"},{"location":"linux/#window__managers","text":"Window managers: - are programs controlling placement and movement of windows on your screen - usually work together with desktop environments - can also be used separately on your Linux machine - are lightweight and can offer better performance than desktop environments - do not ship with unnecessary apps and widget (you even have to install menu and compositor if you go with just a window manager) - can be complicated to set up for non-technical users, since you need to install everything extra yourself Note Some of the popular window managers are: i3wm, bspwm, awesome, Fluxbox KDE Plasma and GNOME desktops use the KWin and Mutter window managers \u201cunder the hood\u201d \u201cGNU Network Object Model Environment (GNOME)\u201d is a desktop environment used by several Linux distros. It is quite similar to the Windows desktop and can be a good choice if you are changing from that OS","title":"Window managers"},{"location":"linux/#commands","text":"The prompts that you type on the terminal are called \u201ccommands\u201d. The terminal is also commonly called the \u201ccommand line\u201d or the \u201ccommand line interface\u201d (CLI). There are several applications that can be used to access the command line, so it will vary how it looks, but it is usually a simple window (commonly white or green on black background or black on white background). Using commands on a command line interface is something many people find to be the most intimidating thing about Linux. However, while the command line is an integral part of using Linux, and some actions may be faster or more direct when done on the command line, most things can actually be done through a Graphical User Interface (GUI).","title":"Commands"},{"location":"linux/#command__line__interface__cli__terminal","text":"The terminal, console, or \u201ccommand line interface\u201d (often abbreviated \u201cCLI\u201d) is a text.based interface which is often the primary way to interact with Linux. The terminal is where you enter your \u201ccommands\u201d . It is usually very straightforward and simple, but you can also choose to use a terminal emulator which will give you a more user-friendly interface. It is a program that is used to control your operating system\u2019s \u201cshell\u201d . Briefly; a shell is a text-based (or graphical interface) through which the user interact with the desktop. Note The Linux terminal is similar to \u201cCommand Prompt\u201d on Windows. It is used by the \u201csuper user\u201d or \u201cadministrator\u201d to control and manage the system efficiently. It can be used to configure settings, for scripting, directly controlling the system, as well as giving various other commands to any program on the system. While other operating systems like Windows once regularly used something like a terminal, it is now more seldom used except for some administrative management. On Linux, however, the terminal is still very much used. This may surprise some, but there are several good reasons: The command line is fast: The CLI is usually much faster than using a GUI, and command-line programs will also start faster that graphical programs due to less overhead. Many programming tools use the command line: compilers, interpreters, debuggers all run on the command line. Yes, there are often a graphical IDE you can install, but that is just a wrapper for the command line program. The command line works everywhere: it is easy to use remotely through SSH, for installing and maintaining servers, you can use it without starting a graphical interface, which gives less overhead and makes it faster and more efficient You can script command line programs: this is a big advantage; you can avoid many repetitive operations when using a script Example: renaming, copying, or moving many files through a graphical file manager can be a hassle. On the command line you can script it. For instance, copying all your .dat files to a directory could be done like this: cp *.dat /mydir You can also use scripting for more complicated tasks. Some of the most commonly used scripting languages are the shell, perl, and Python.","title":"Command line interface (CLI), terminal"},{"location":"linux/#root__user","text":"All Linux operating systems have a built-in system of user roles, where each user has a specific role, with varying levels of permissions. Some of the common roles are: - user: nothing more, nothing less. The user can normally do what they want in their own home directory and perhaps a few other directories where they have been given permission to work. A user cannot install anything to the system outside of these directories where they have permission, and also cannot change most setup files (other than those affecting only themself). - root: The root user or root account has administrative priviliges; complete access to all configurations, commands, and files in the system. Other words for root is superuser or administrator , though root is the most common term on Linux. Note root refers to both the root directory and the root user . The root directory is the top level/parent directory containing all files and folders of the system. It is designated with a \u201c/\u201d, and this is how you can denote it in your commands.","title":"Root, user"},{"location":"linux/#package__manager","text":"On Linux, the programs you install are often referred to as \u201cpackages\u201d. Commonly, they are installed on the command line. A \u201cpackage manager\u201d is a tool that gives you a graphical interface to help you find new packages, install, update, and sometimes even configure them. On Linux, most apps are distributed as packages and are available in the official repositories of your distribution. You can also add third-party repositories with a package manager if you want access to even more packages. There are several different package managers available for the different Linux distros. These are some of the popular ones: - APT: used by Debian and Ubuntu-based distributions. - RPM: used by Fedora, CentOS, and RHEL. - pacman: used by Arch Linux and its derivatives. - yum/dnf: used by Red Hat-based distributions.","title":"Package manager"},{"location":"linux/#source__and__binary__packages","text":"Source packages: these contain the source code of a program: A user must manually compile and install it to run the software. Binary packages: these contain prebuilt and pre-compiled executables for the software.","title":"Source and binary packages"},{"location":"linux/#repositories","text":"Collections of packages and their metadata can be found in software repositories on remote servers. Most Linux distros has their own set of repositories or else they use the repositories of their parent distro.","title":"Repositories"},{"location":"linux/#open__source","text":"Wikipedia defines Open Source as: Source code that is made freely available for possible modification and redistribution. Products include permission to use the source code, design documents, or content of the product. The open-source model is a decentralized software development model that encourages open collaboration. A main principle of open-source software development is peer production, with products such as source code, blueprints, and documentation freely available to the public. The open-source movement in software began as a response to the limitations of proprietary code. Open source has played a significant role in the growth and popularity of Linux.","title":"Open Source"},{"location":"modify/","text":"Modifying the file tree \u00b6 Learning objectives Questions How do I create or remove files and directories? How do I copy or rename files and directories? (You will see why these two operations are mentioned together shortly.) Learning objectives Learn how to create and remove files and directories. Learn how to copy and rename/move files and directories. Learn to avoid a few common pitfalls that could cause files to be deleted or overwritten by mistake. Create and remove directories/files \u00b6 This section will show how to work with files and directories through the command line interface (CLI). Files \u00b6 To create files, you would normally use an editor ( nano , vim , emacs , etc.), but you can also create an empty file with the command touch . touch FILE You can remove files with rm . You can use the flag/option -i to prompt before removing a file. Be aware that files removed with rm are deleted permanently \u2014they generally cannot be restored (people have gotten lucky with system backup snapshots, but do not assume that those will be available). Examples Create a file called file.txt touch file.txt Remove the file file.txt rm file.txt Warning If you do not add the flag/option -i the file will be deleted without prompting. Be careful! Be extra careful using rm -rf with glob patterns (see Wild Cards under The File System )! It is strongly recommended that you always test a pattern with ls and check that the output is what you expect before using rm -rf on that pattern. Directories \u00b6 mkdir DIR : Creates a directory DIR mkdir -p DIR/SUBDIR : creates a directory DIR with the subdirectory SUBDIR rm -r DIR : Removes a directory DIR. The flag -r means recursively. You can also add -f (meaning force). This means ignore nonexistent files and arguments, and never ask before deleting the target. Again, you can add the option -i . This means it will prompt before every removal. Examples: creating and removing directories Create a directory called mynewdir mkdir mynewdir Create a directory called cooldir which has a subdirectory called fancydir mkdir -p cooldir/fancydir Remove the directory mynewdir rm -r mynewdir Examples \u00b6 Reminder mkdir DIR : Create a directory DIR rm -rf DIR : Remove a directory DIR. The flag \u201c-r\u201d means recursively and \u201c-f\u201d means do so without asking for each file and subdirectory. Useful, but dangerous. Be careful! cd : Go to your home directory ($HOME) cd DIR : Change directory to DIR cd .. : Change directory to the parent directory of the current directory cd - : Go back to the previous working directory touch FILE : Create an empty file with the name FILE or update the timestamps of an existing file named FILE rm FILE : Remove the file with the name FILE pwd : print the current working directory path in full. Creating directories, changing directories, removing directory and file, removing files by pattern This example sequence will demonstrate some of the things we just learned, as well as the command cd and glob patterns from the previous section. HINT: Code-along! Create and remove directories: [ x_rebpi@tetralith1 ~ ] $ mkdir mytestdir [ x_rebpi@tetralith1 ~ ] $ cd mytestdir/ [ x_rebpi@tetralith1 mytestdir ] $ mkdir testdir1 [ x_rebpi@tetralith1 mytestdir ] $ mkdir testdir2 [ x_rebpi@tetralith1 mytestdir ] $ mkdir testdir3 [ x_rebpi@tetralith1 mytestdir ] $ ls testdir1 testdir2 testdir3 [ x_rebpi@tetralith1 mytestdir ] $ rm -rf testdir3 [ x_rebpi@tetralith1 mytestdir ] $ ls testdir1 testdir2 Create and remove files: [ x_rebpi@tetralith1 mytestdir ] $ cd testdir1 [ x_rebpi@tetralith1 testdir1 ] $ touch file1.txt [ x_rebpi@tetralith1 testdir1 ] $ touch file2.sh [ x_rebpi@tetralith1 testdir1 ] $ touch file3.c [ x_rebpi@tetralith1 testdir1 ] $ touch file4.dat [ x_rebpi@tetralith1 testdir1 ] $ rm file4.dat [ x_rebpi@tetralith3 testdir1 ] $ rm -i file3.c rm: remove regular empty file 'file3.c' ? y [ x_rebpi@tetralith3 testdir1 ] $ ls file1.txt file2.sh Removing files by glob pattern (or why to always test a glob pattern with ls before using it with rm ): [ x_rebpi@tetralith1 testdir1 ] $ cd ../testdir2 [ x_rebpi@tetralith1 testdir2 ] $ touch meow.txt [ x_rebpi@tetralith1 testdir2 ] $ touch catsmeow1.dat [ x_rebpi@tetralith1 testdir2 ] $ touch homeowners_assoc.odt [ x_rebpi@tetralith1 testdir2 ] $ ls *meow* catsmeow1.dat homeowners_assoc.odt meow.txt [ x_rebpi@tetralith1 testdir2 ] $ rm -r *meow { ,1 } .??t [ x_rebpi@tetralith1 testdir2 ] $ ls homeowners_assoc.odt Note This was done on Tetralith. You will notice that only the current (subdir) is shown in the prompt. At some other centres all the (sub)dirs would be shown. Example: HPC2N b-an01 [ ~ ] $ cd mytestdir b-an01 [ ~/mytestdir ] $ cd testdir1 b-an01 [ ~/mytestdir/testdir1 ] $ cp - copy files/directories \u00b6 This command is used to copy files or directories. cp myfile.txt myfile2.txt : make a copy of \u201cmyfile.txt\u201d named \u201cmyfile2.txt\u201d cp myfile.txt DIR/ : copy the file \u201cmyfile.txt\u201d into the directory DIR cp DIR1/ DIR2/ : copy the directory DIR1 into the directory DIR2 (Note: only works if DIR1 contains no subdirectories) cp -r DIR1/ DIR2/ : copy the directory DIR1 and all subdirectories into the directory DIR2. cp -i file.txt DIR/ : Interactive. It will ask before overwriting if there is a file with the same name. Warning If you do not add the option \u201c-i\u201d, you risk overwriting any existing file with the same name. Code-along Go to the directory mytestdir under exercises directory that you got from the downloaded tarball. This is how the structure looks: Change to the subdirectory: cd exercises cd mytestdir 2. Copy the file myfile.txt to the subdirectory testdir1 : cp myfile.txt testdir1 3. Create a new directory called testdir3 inside testdir1 cd testdir1 mkdir testdir3 4. Copy the new subdirectory testdir3 to the directory testdir2 . Remember, \u201ctestdir2\u201d is located outside \u201ctestdir1\u201d and at the same \u201clevel\u201d. This can be done in more than one way. Remember you need the option -r (for recursive) when copying directories: a) \"Go up one\" and then copy: ```bash cd .. cp -r testdir1/testdir3 testdir2/ ``` b) Copy from inside ``testdir1`` ```bash cp -r testdir3 ../testdir2 ``` If you give the full path while copying, this can be done from anywhere. mv - rename files/directories \u00b6 The command mv is used to rename files and directories, and to move a file or directory to another location. mv file1.txt file2.txt : renames file1.txt to file2.txt mv DIR1/ DIR2/ : renames directory DIR1 to directory DIR2/ mv file1.txt DIR1/ : moves the file file1.txt into the directory DIR1/ mv DIR1 DIR2/ : (note lack of forward slash after DIR1 ) moves directory DIR1 into directory DIR2/ . mv -i file1.txt file2.txt : interactive. Asks before overwriting if there is already a file with the destination name. mv -i DIR1/ DIR2/ : interactive. Asks before overwriting, if there is already a directory with that name. Tip mv complains if there is already a file/directory with the new name. You can force the renaming with \u201c-f\u201d at the cost of the disappearence of the file that previously held the name. Exercise \u00b6 Exercise Create three files (touch) Create a directory and then create a subdirectory of that directory (mkdir, cd) Create a file in the subdirectory (touch) Create another file inside the directory you created and then move it to the subdirectory you created (touch, cd, mv) Rename one of the directories (mv) Delete/remove a file (rm) Delete/remove the subdirectory (rm) Solution - click to reveal I randomly name the files afile.txt , bfile.txt , cfile.txt touch afile.txt touch bfile.txt touch cfile.txt I make the directory newdir and the subdirectory subdir mkdir newdir cd newdir mkdir subdir I create a file named newfile.dat cd subdir touch newfile.dat I name the file secondfile.txt and move it into subdir cd .. touch secondfile.txt mv secondfile.txt subdir I rename the first directory (top-level directory) I created, calling it fancydir cd .. mv newdir fancydir I remove the file afile.txt while working in the directory outside of fancydir (previously called newdir ) rm fancydir/afile.txt I remove the subdirectory subdir while outside the directory fancydir rm -r fancydir/subdir Tip You can always check with pwd which directory you are working in! Symbolic links \u00b6 A symbolic link is a pointer to another file or directory. Symbolic links are also called soft links, or just symlinks. Symlinks are useful both for ease\u2014you avoid using a long path each time you change to a directory, like your project directory\u2014and to avoid changing hard links within other scripts or programs. It is good to avoid changing hardlinks if you, for instance, install a program or use a script that assumes the library it uses is called libcoolness.a and not libcoolness.2.0.a . You can then just update the symlink instead of renaming the library or updating potentially many instances where it is mentioned in the program. Command: ln -s real-file-or-lib link-name Example (on Tetralith) ln -s /proj/spring-courses-naiss/users/MYUSERNAME $HOME /myproj This creates a symbolic link named \u201cmyproj\u201d in your home directory, pointing to the location /proj/spring-courses-naiss/users/MYUSERNAME. The directory \u201cspring-courses-naiss\u201d is the project storage directory for this course project. For user x_rebpi , it would look like this: [ x_rebpi@tetralith1 ~ ] $ ls -l total 2 lrwxrwxrwx 1 x_rebpi x_rebpi 31 Sep 11 12 :01 myproj -> /proj/spring-courses-naiss/users/x_rebpi drwxrwxr-x 4 x_rebpi x_rebpi 4096 Sep 11 11 :43 mytestdir Summary You can create a directory named DIR with mkdir DIR You can remove a directory named DIR with rm -r DIR You can create an (empty) file named FILE with touch FILE You can remove a file named FILE with rm FILE The command to copy files and directories is cp The command to rename files and directories is mv Symbolic links are pointers to another file or directory Always test glob patterns with ls before using the same patterns with rm -r to remove files in bulk.","title":"Modifying the file tree"},{"location":"modify/#modifying__the__file__tree","text":"Learning objectives Questions How do I create or remove files and directories? How do I copy or rename files and directories? (You will see why these two operations are mentioned together shortly.) Learning objectives Learn how to create and remove files and directories. Learn how to copy and rename/move files and directories. Learn to avoid a few common pitfalls that could cause files to be deleted or overwritten by mistake.","title":"Modifying the file tree"},{"location":"modify/#create__and__remove__directoriesfiles","text":"This section will show how to work with files and directories through the command line interface (CLI).","title":"Create and remove directories/files"},{"location":"modify/#files","text":"To create files, you would normally use an editor ( nano , vim , emacs , etc.), but you can also create an empty file with the command touch . touch FILE You can remove files with rm . You can use the flag/option -i to prompt before removing a file. Be aware that files removed with rm are deleted permanently \u2014they generally cannot be restored (people have gotten lucky with system backup snapshots, but do not assume that those will be available). Examples Create a file called file.txt touch file.txt Remove the file file.txt rm file.txt Warning If you do not add the flag/option -i the file will be deleted without prompting. Be careful! Be extra careful using rm -rf with glob patterns (see Wild Cards under The File System )! It is strongly recommended that you always test a pattern with ls and check that the output is what you expect before using rm -rf on that pattern.","title":"Files"},{"location":"modify/#directories","text":"mkdir DIR : Creates a directory DIR mkdir -p DIR/SUBDIR : creates a directory DIR with the subdirectory SUBDIR rm -r DIR : Removes a directory DIR. The flag -r means recursively. You can also add -f (meaning force). This means ignore nonexistent files and arguments, and never ask before deleting the target. Again, you can add the option -i . This means it will prompt before every removal. Examples: creating and removing directories Create a directory called mynewdir mkdir mynewdir Create a directory called cooldir which has a subdirectory called fancydir mkdir -p cooldir/fancydir Remove the directory mynewdir rm -r mynewdir","title":"Directories"},{"location":"modify/#examples","text":"Reminder mkdir DIR : Create a directory DIR rm -rf DIR : Remove a directory DIR. The flag \u201c-r\u201d means recursively and \u201c-f\u201d means do so without asking for each file and subdirectory. Useful, but dangerous. Be careful! cd : Go to your home directory ($HOME) cd DIR : Change directory to DIR cd .. : Change directory to the parent directory of the current directory cd - : Go back to the previous working directory touch FILE : Create an empty file with the name FILE or update the timestamps of an existing file named FILE rm FILE : Remove the file with the name FILE pwd : print the current working directory path in full. Creating directories, changing directories, removing directory and file, removing files by pattern This example sequence will demonstrate some of the things we just learned, as well as the command cd and glob patterns from the previous section. HINT: Code-along! Create and remove directories: [ x_rebpi@tetralith1 ~ ] $ mkdir mytestdir [ x_rebpi@tetralith1 ~ ] $ cd mytestdir/ [ x_rebpi@tetralith1 mytestdir ] $ mkdir testdir1 [ x_rebpi@tetralith1 mytestdir ] $ mkdir testdir2 [ x_rebpi@tetralith1 mytestdir ] $ mkdir testdir3 [ x_rebpi@tetralith1 mytestdir ] $ ls testdir1 testdir2 testdir3 [ x_rebpi@tetralith1 mytestdir ] $ rm -rf testdir3 [ x_rebpi@tetralith1 mytestdir ] $ ls testdir1 testdir2 Create and remove files: [ x_rebpi@tetralith1 mytestdir ] $ cd testdir1 [ x_rebpi@tetralith1 testdir1 ] $ touch file1.txt [ x_rebpi@tetralith1 testdir1 ] $ touch file2.sh [ x_rebpi@tetralith1 testdir1 ] $ touch file3.c [ x_rebpi@tetralith1 testdir1 ] $ touch file4.dat [ x_rebpi@tetralith1 testdir1 ] $ rm file4.dat [ x_rebpi@tetralith3 testdir1 ] $ rm -i file3.c rm: remove regular empty file 'file3.c' ? y [ x_rebpi@tetralith3 testdir1 ] $ ls file1.txt file2.sh Removing files by glob pattern (or why to always test a glob pattern with ls before using it with rm ): [ x_rebpi@tetralith1 testdir1 ] $ cd ../testdir2 [ x_rebpi@tetralith1 testdir2 ] $ touch meow.txt [ x_rebpi@tetralith1 testdir2 ] $ touch catsmeow1.dat [ x_rebpi@tetralith1 testdir2 ] $ touch homeowners_assoc.odt [ x_rebpi@tetralith1 testdir2 ] $ ls *meow* catsmeow1.dat homeowners_assoc.odt meow.txt [ x_rebpi@tetralith1 testdir2 ] $ rm -r *meow { ,1 } .??t [ x_rebpi@tetralith1 testdir2 ] $ ls homeowners_assoc.odt Note This was done on Tetralith. You will notice that only the current (subdir) is shown in the prompt. At some other centres all the (sub)dirs would be shown. Example: HPC2N b-an01 [ ~ ] $ cd mytestdir b-an01 [ ~/mytestdir ] $ cd testdir1 b-an01 [ ~/mytestdir/testdir1 ] $","title":"Examples"},{"location":"modify/#cp__-__copy__filesdirectories","text":"This command is used to copy files or directories. cp myfile.txt myfile2.txt : make a copy of \u201cmyfile.txt\u201d named \u201cmyfile2.txt\u201d cp myfile.txt DIR/ : copy the file \u201cmyfile.txt\u201d into the directory DIR cp DIR1/ DIR2/ : copy the directory DIR1 into the directory DIR2 (Note: only works if DIR1 contains no subdirectories) cp -r DIR1/ DIR2/ : copy the directory DIR1 and all subdirectories into the directory DIR2. cp -i file.txt DIR/ : Interactive. It will ask before overwriting if there is a file with the same name. Warning If you do not add the option \u201c-i\u201d, you risk overwriting any existing file with the same name. Code-along Go to the directory mytestdir under exercises directory that you got from the downloaded tarball. This is how the structure looks: Change to the subdirectory: cd exercises cd mytestdir 2. Copy the file myfile.txt to the subdirectory testdir1 : cp myfile.txt testdir1 3. Create a new directory called testdir3 inside testdir1 cd testdir1 mkdir testdir3 4. Copy the new subdirectory testdir3 to the directory testdir2 . Remember, \u201ctestdir2\u201d is located outside \u201ctestdir1\u201d and at the same \u201clevel\u201d. This can be done in more than one way. Remember you need the option -r (for recursive) when copying directories: a) \"Go up one\" and then copy: ```bash cd .. cp -r testdir1/testdir3 testdir2/ ``` b) Copy from inside ``testdir1`` ```bash cp -r testdir3 ../testdir2 ``` If you give the full path while copying, this can be done from anywhere.","title":"cp - copy files/directories"},{"location":"modify/#mv__-__rename__filesdirectories","text":"The command mv is used to rename files and directories, and to move a file or directory to another location. mv file1.txt file2.txt : renames file1.txt to file2.txt mv DIR1/ DIR2/ : renames directory DIR1 to directory DIR2/ mv file1.txt DIR1/ : moves the file file1.txt into the directory DIR1/ mv DIR1 DIR2/ : (note lack of forward slash after DIR1 ) moves directory DIR1 into directory DIR2/ . mv -i file1.txt file2.txt : interactive. Asks before overwriting if there is already a file with the destination name. mv -i DIR1/ DIR2/ : interactive. Asks before overwriting, if there is already a directory with that name. Tip mv complains if there is already a file/directory with the new name. You can force the renaming with \u201c-f\u201d at the cost of the disappearence of the file that previously held the name.","title":"mv - rename files/directories"},{"location":"modify/#exercise","text":"Exercise Create three files (touch) Create a directory and then create a subdirectory of that directory (mkdir, cd) Create a file in the subdirectory (touch) Create another file inside the directory you created and then move it to the subdirectory you created (touch, cd, mv) Rename one of the directories (mv) Delete/remove a file (rm) Delete/remove the subdirectory (rm) Solution - click to reveal I randomly name the files afile.txt , bfile.txt , cfile.txt touch afile.txt touch bfile.txt touch cfile.txt I make the directory newdir and the subdirectory subdir mkdir newdir cd newdir mkdir subdir I create a file named newfile.dat cd subdir touch newfile.dat I name the file secondfile.txt and move it into subdir cd .. touch secondfile.txt mv secondfile.txt subdir I rename the first directory (top-level directory) I created, calling it fancydir cd .. mv newdir fancydir I remove the file afile.txt while working in the directory outside of fancydir (previously called newdir ) rm fancydir/afile.txt I remove the subdirectory subdir while outside the directory fancydir rm -r fancydir/subdir Tip You can always check with pwd which directory you are working in!","title":"Exercise"},{"location":"modify/#symbolic__links","text":"A symbolic link is a pointer to another file or directory. Symbolic links are also called soft links, or just symlinks. Symlinks are useful both for ease\u2014you avoid using a long path each time you change to a directory, like your project directory\u2014and to avoid changing hard links within other scripts or programs. It is good to avoid changing hardlinks if you, for instance, install a program or use a script that assumes the library it uses is called libcoolness.a and not libcoolness.2.0.a . You can then just update the symlink instead of renaming the library or updating potentially many instances where it is mentioned in the program. Command: ln -s real-file-or-lib link-name Example (on Tetralith) ln -s /proj/spring-courses-naiss/users/MYUSERNAME $HOME /myproj This creates a symbolic link named \u201cmyproj\u201d in your home directory, pointing to the location /proj/spring-courses-naiss/users/MYUSERNAME. The directory \u201cspring-courses-naiss\u201d is the project storage directory for this course project. For user x_rebpi , it would look like this: [ x_rebpi@tetralith1 ~ ] $ ls -l total 2 lrwxrwxrwx 1 x_rebpi x_rebpi 31 Sep 11 12 :01 myproj -> /proj/spring-courses-naiss/users/x_rebpi drwxrwxr-x 4 x_rebpi x_rebpi 4096 Sep 11 11 :43 mytestdir Summary You can create a directory named DIR with mkdir DIR You can remove a directory named DIR with rm -r DIR You can create an (empty) file named FILE with touch FILE You can remove a file named FILE with rm FILE The command to copy files and directories is cp The command to rename files and directories is mv Symbolic links are pointers to another file or directory Always test glob patterns with ls before using the same patterns with rm -r to remove files in bulk.","title":"Symbolic links"},{"location":"more-commands/","text":"More (advanced) commands. \u00b6 Alias \u00b6 You will often have to write the same command again and again. If it is a longer command, it is reducing your productivity having to repeat it. Then you can use the alias command to create an \u2018alias\u2019 for your command. To see the currently definted aliases, execute the \u2018alias\u2019 command: $ alias Example This is how it might look when you run alias : b-an01 [ ~ ] $ alias alias cdn = 'cat >/dev/null' alias dir = 'ls -lAF' alias l = 'dir' alias ls = 'ls -F' As an example, this means that if you type \u2018dir\u2019 the actual command that is executed is \u2018ls -lAF\u2019. In order to create a new alias, you could write: $ alias shortName = \"your custom command here\" Warning The alias will only be valid in that shell, and only until you logout. Next time you will have to issue the \u2018alias\u2019 command again, unless you add it to either your .bashrc or .bash.profile file. Adding a new alias to the .bashrc file, using \u2018nano\u2019 editor Open the file: nano ~/.bashrc Inside the editor, scroll down to where your aliases are. If you do not have any, just add them at the end, like this #My custom aliases alias c = \"clear\" alias ll = \"ls -alF\" # Colourize ls output alias ls = 'ls --color=auto' # Colourize grep output alias grep = 'grep --color=auto' # Easily list my SLURM batch jobs alias jobs = 'squeue -u $USER' # Find all entries starting with d in the output from the ls -lahrt command alias ldir = \u2019ls -lahrt | egrep \"^d\" \u2019 Save and Exit the file: CTRL-x (Press CTRL and hold it down while pressing x). Answer \u2018Y\u2019 to save. Next time you start a shell or after a new login your new alias is available. To make it available immediately, run $ source ~/.bashrc awk \u00b6 Powerful, but somewhat more advanced command! This command finds patterns in a file and can perform arithmetic/string operations. You can use it to transform data files and produce formatted reports. It allows the user to use variables, numeric functions, string functions, and logical operators. Things awk can do: Scan a file line by line Split each input line into fields Compare input line/fields to pattern Perform action(s) on matched lines Search for the pattern \u2018snow\u2019 in the file FILE and print out the first column awk '/snow/ {print$1}' FILE Print column 3 and 4 from file mydata.dat awk '{print $3 \"\\t\" $4}' mydata.dat Print column 2 and 3 from file mydata.dat, but only those rows that contain the letter \u2018r\u2019 awk '/r/ {print $2 \"\\t\" $3}' mydata.dat chown - change ownership \u00b6 To change ownership of a file or directory, use the command chown . chown [ OPTIONS ] USER [ :GROUP ] FILE ( s ) Examples chown USERNAME FILE the user with USERNAME becomes the new owner of FILE chown USERNAME DIRECTORY the user with USERNAME becomes the new owner of DIRECTORY (but not any subdirectories) chown USERNAME:folk DIRECTORY the user ownership is changed to USER and the group ownership to group \u201cfolk\u201d for the directory DIRECTORY chown :folk DIRECTORY the group ownership is changed to the group \u201cfolk\u201d for the directory DIRECTORY chown -R USERNAME:folk DIRECTORY the user ownership is changed to USERNAME and the group ownership is changed to group \u201cfolk\u201d for the directory DIRECTORY and all subdirectories Warning As default, chown does not generate output on success and returns zero.","title":"More commands"},{"location":"more-commands/#more__advanced__commands","text":"","title":"More (advanced) commands."},{"location":"more-commands/#alias","text":"You will often have to write the same command again and again. If it is a longer command, it is reducing your productivity having to repeat it. Then you can use the alias command to create an \u2018alias\u2019 for your command. To see the currently definted aliases, execute the \u2018alias\u2019 command: $ alias Example This is how it might look when you run alias : b-an01 [ ~ ] $ alias alias cdn = 'cat >/dev/null' alias dir = 'ls -lAF' alias l = 'dir' alias ls = 'ls -F' As an example, this means that if you type \u2018dir\u2019 the actual command that is executed is \u2018ls -lAF\u2019. In order to create a new alias, you could write: $ alias shortName = \"your custom command here\" Warning The alias will only be valid in that shell, and only until you logout. Next time you will have to issue the \u2018alias\u2019 command again, unless you add it to either your .bashrc or .bash.profile file. Adding a new alias to the .bashrc file, using \u2018nano\u2019 editor Open the file: nano ~/.bashrc Inside the editor, scroll down to where your aliases are. If you do not have any, just add them at the end, like this #My custom aliases alias c = \"clear\" alias ll = \"ls -alF\" # Colourize ls output alias ls = 'ls --color=auto' # Colourize grep output alias grep = 'grep --color=auto' # Easily list my SLURM batch jobs alias jobs = 'squeue -u $USER' # Find all entries starting with d in the output from the ls -lahrt command alias ldir = \u2019ls -lahrt | egrep \"^d\" \u2019 Save and Exit the file: CTRL-x (Press CTRL and hold it down while pressing x). Answer \u2018Y\u2019 to save. Next time you start a shell or after a new login your new alias is available. To make it available immediately, run $ source ~/.bashrc","title":"Alias"},{"location":"more-commands/#awk","text":"Powerful, but somewhat more advanced command! This command finds patterns in a file and can perform arithmetic/string operations. You can use it to transform data files and produce formatted reports. It allows the user to use variables, numeric functions, string functions, and logical operators. Things awk can do: Scan a file line by line Split each input line into fields Compare input line/fields to pattern Perform action(s) on matched lines Search for the pattern \u2018snow\u2019 in the file FILE and print out the first column awk '/snow/ {print$1}' FILE Print column 3 and 4 from file mydata.dat awk '{print $3 \"\\t\" $4}' mydata.dat Print column 2 and 3 from file mydata.dat, but only those rows that contain the letter \u2018r\u2019 awk '/r/ {print $2 \"\\t\" $3}' mydata.dat","title":"awk"},{"location":"more-commands/#chown__-__change__ownership","text":"To change ownership of a file or directory, use the command chown . chown [ OPTIONS ] USER [ :GROUP ] FILE ( s ) Examples chown USERNAME FILE the user with USERNAME becomes the new owner of FILE chown USERNAME DIRECTORY the user with USERNAME becomes the new owner of DIRECTORY (but not any subdirectories) chown USERNAME:folk DIRECTORY the user ownership is changed to USER and the group ownership to group \u201cfolk\u201d for the directory DIRECTORY chown :folk DIRECTORY the group ownership is changed to the group \u201cfolk\u201d for the directory DIRECTORY chown -R USERNAME:folk DIRECTORY the user ownership is changed to USERNAME and the group ownership is changed to group \u201cfolk\u201d for the directory DIRECTORY and all subdirectories Warning As default, chown does not generate output on success and returns zero.","title":"chown - change ownership"},{"location":"patterns/","text":"Finding patterns \u00b6 Learning objectives Questions How do I find out if a specific pattern is in a file? What are regular expressions? (advanced) Objectives Learn about finding patterns Learn to use grep and find Learn to use regular expressions (advanced) This section will look at finding patterns ( grep , find , and regular expressions ). Here you will find descriptions on how to search for files with specific patterns. Code along! Try out / code along for some of these examples. You can use the contents of the directory /exercises/patterns that you got from the downloaded tarball ( exercises.tar.gz ) to play with. If you have not done so already, right-click and save to download, or right-click and copy the url, then do wget THE-URL-YOU-COPIED in a terminal window to download it there. Then do tar -zxvf patterns.tar.gz to unpack. grep \u00b6 This command searches for patterns in text files. Syntax: grep [ options ] [ FILE ] FILE is the name of whatever file you want to look at. Some commonly used options are: -i : ignore case -o : only output the instance of the pattern you search for, not the full line -e : use a regular expression as pattern, can be used multiple times (OR operation), protects patterns starting with \u201c-\u201c -c : do not output the line, just print a count of matching lines -n : Prefix each line of output with the 1-based line number within its input file. -r : Read all files under each directory, recursively. If no file operand is given, grep searches the working directory. See man grep for more options. Examples Code along A good file to use here is fil.txt in the exercises/patterns directory. You will also use newfile.txt and fil.txt in the same directory. In the following examples/exercises replace the string FILE with the file name (single search) or the path to the folder (recursive search). Find the pattern \u2018word\u2019 in FILE grep 'word' FILE Find the pattern \u2018word\u2019 recursively under the directory path/to/dir grep -rine 'word' path/to/dir Exercises Try finding the pattern string in newfile.txt This file is also located in the exercises/patterns directory. Click to reveal solution Search for instances of the word \u2018contains\u2019 in fil.txt and count them Click to reveal solution grep -o -i contains fil.txt | wc -l Search for the lines with instances of \u2018word\u2019 in fil.txt and output them to file.out Click to reveal solution grep word fil.txt > file.out Search for the lines with instances of \u2018string\u2019 in newfile.txt and append them to file.out Click to reveal solution grep string newfile.txt >> file.out find \u00b6 The find command is used for file and directory search. You can search by name, size, modification time, or content. Syntax find [ path ] [ options ] [ expression ] path is the starting directory for the search options are settings or conditions that modify how the search is performed expression is the criteria for filtering and locating files (for instance, only search for txt files or only files named docs ). Useful common options -type f : only search for files -type d : only search for directories -name NAME : only search for files with a specific name NAME or pattern -size [+/-]n : Searches for files based on size. +n finds larger files, -n finds smaller files. n measures size in units of space. -mtime n : Finds files based on modification time. n represents the number of days ago. -exec command {} \\; : Executes a command on each file found. For more options, check man find Exercises Try yourself You could do the searches inside exercises directory or inside exercises/patterns directory. Find the file fil4.txt in the directory you are standing in and below Click to reveal solution find . -type f -name \"fil4.txt\" Find the file myfile0.txt which is part of the name in the directory expressions/patterns while standing in exercises/script Click to reveal solution find ../patterns/ -type f -name \"myfile0.txt\" * Advanced Material - Regular Expressions \u00b6 Regular Expressions are a type of patterns that are used when you are working with text. Due to their convenience, regular expressions are commonly used in programming languages, though their syntax may vary between languages. Regular Expressions can be used with commands like grep , find and many others. Note If your regular expressions does not do as you expect, you may need to use single quotation marks around the sentence and you may also have to use backslashes on every single special character. There are online tools that allow you to test Regular Expressions, for instance, regex101.com . Different languages are supported. For not too complex Regular Expressions, most of the languages options could work for grep and find . Make dry-runs (tests) before running commands with Regular Expressions that modify files. Some common examples of regular expressions: . matches any single character. Same as ? in standard wildcard expressions. \\ is used as an \u201cescape\u201d character for a subsequent special character. . * is used to match any string, equivalent to * in standard wildcards. * the proceeding item is matched zero or more times. ie. n* will match n, nn, nnnn, nnnnnnn but not na or any other character. ^ means \u201cthe beginning of the line\u201d. So \u201c^a\u201d means find a line starting with an \u201ca\u201d. $ means \u201cthe end of the line\u201d. So \u201ca$\u201d means find a line ending with an \u201ca\u201d. [ ] specifies a range. Same as for normal wildcards. This is an \u2018or\u2019 relationship (you only need one to match). | This wildcard makes a logical OR relationship between wildcards. You can thus search something or something else. You may need to add a \u2018' before this command to avoid the shell thinking you want a pipe. [^] This is the equivalent of [!] in standard wildcards, i.e. it is a logical \u201cnot\u201d and will match anything not listed within the square brackets. Advanced example This command searches the file myfile for lines starting with an \u201cp\u201d and ending with an \u201ce\u201d, and prints them to the standard output. $ cat myfile | grep '^p.*e$' Remember to not include the first $ if you copy the command! It is the prompt! Keypoints Finding files with specific patterns in their names or content can be done with grep and find Regular Expressions are a type of patterns that are used when you are working with text. They can be used with grep , find , and other programs","title":"Finding patterns"},{"location":"patterns/#finding__patterns","text":"Learning objectives Questions How do I find out if a specific pattern is in a file? What are regular expressions? (advanced) Objectives Learn about finding patterns Learn to use grep and find Learn to use regular expressions (advanced) This section will look at finding patterns ( grep , find , and regular expressions ). Here you will find descriptions on how to search for files with specific patterns. Code along! Try out / code along for some of these examples. You can use the contents of the directory /exercises/patterns that you got from the downloaded tarball ( exercises.tar.gz ) to play with. If you have not done so already, right-click and save to download, or right-click and copy the url, then do wget THE-URL-YOU-COPIED in a terminal window to download it there. Then do tar -zxvf patterns.tar.gz to unpack.","title":"Finding patterns"},{"location":"patterns/#grep","text":"This command searches for patterns in text files. Syntax: grep [ options ] [ FILE ] FILE is the name of whatever file you want to look at. Some commonly used options are: -i : ignore case -o : only output the instance of the pattern you search for, not the full line -e : use a regular expression as pattern, can be used multiple times (OR operation), protects patterns starting with \u201c-\u201c -c : do not output the line, just print a count of matching lines -n : Prefix each line of output with the 1-based line number within its input file. -r : Read all files under each directory, recursively. If no file operand is given, grep searches the working directory. See man grep for more options. Examples Code along A good file to use here is fil.txt in the exercises/patterns directory. You will also use newfile.txt and fil.txt in the same directory. In the following examples/exercises replace the string FILE with the file name (single search) or the path to the folder (recursive search). Find the pattern \u2018word\u2019 in FILE grep 'word' FILE Find the pattern \u2018word\u2019 recursively under the directory path/to/dir grep -rine 'word' path/to/dir Exercises Try finding the pattern string in newfile.txt This file is also located in the exercises/patterns directory. Click to reveal solution Search for instances of the word \u2018contains\u2019 in fil.txt and count them Click to reveal solution grep -o -i contains fil.txt | wc -l Search for the lines with instances of \u2018word\u2019 in fil.txt and output them to file.out Click to reveal solution grep word fil.txt > file.out Search for the lines with instances of \u2018string\u2019 in newfile.txt and append them to file.out Click to reveal solution grep string newfile.txt >> file.out","title":"grep"},{"location":"patterns/#find","text":"The find command is used for file and directory search. You can search by name, size, modification time, or content. Syntax find [ path ] [ options ] [ expression ] path is the starting directory for the search options are settings or conditions that modify how the search is performed expression is the criteria for filtering and locating files (for instance, only search for txt files or only files named docs ). Useful common options -type f : only search for files -type d : only search for directories -name NAME : only search for files with a specific name NAME or pattern -size [+/-]n : Searches for files based on size. +n finds larger files, -n finds smaller files. n measures size in units of space. -mtime n : Finds files based on modification time. n represents the number of days ago. -exec command {} \\; : Executes a command on each file found. For more options, check man find Exercises Try yourself You could do the searches inside exercises directory or inside exercises/patterns directory. Find the file fil4.txt in the directory you are standing in and below Click to reveal solution find . -type f -name \"fil4.txt\" Find the file myfile0.txt which is part of the name in the directory expressions/patterns while standing in exercises/script Click to reveal solution find ../patterns/ -type f -name \"myfile0.txt\"","title":"find"},{"location":"patterns/#advanced__material__-__regular__expressions","text":"Regular Expressions are a type of patterns that are used when you are working with text. Due to their convenience, regular expressions are commonly used in programming languages, though their syntax may vary between languages. Regular Expressions can be used with commands like grep , find and many others. Note If your regular expressions does not do as you expect, you may need to use single quotation marks around the sentence and you may also have to use backslashes on every single special character. There are online tools that allow you to test Regular Expressions, for instance, regex101.com . Different languages are supported. For not too complex Regular Expressions, most of the languages options could work for grep and find . Make dry-runs (tests) before running commands with Regular Expressions that modify files. Some common examples of regular expressions: . matches any single character. Same as ? in standard wildcard expressions. \\ is used as an \u201cescape\u201d character for a subsequent special character. . * is used to match any string, equivalent to * in standard wildcards. * the proceeding item is matched zero or more times. ie. n* will match n, nn, nnnn, nnnnnnn but not na or any other character. ^ means \u201cthe beginning of the line\u201d. So \u201c^a\u201d means find a line starting with an \u201ca\u201d. $ means \u201cthe end of the line\u201d. So \u201ca$\u201d means find a line ending with an \u201ca\u201d. [ ] specifies a range. Same as for normal wildcards. This is an \u2018or\u2019 relationship (you only need one to match). | This wildcard makes a logical OR relationship between wildcards. You can thus search something or something else. You may need to add a \u2018' before this command to avoid the shell thinking you want a pipe. [^] This is the equivalent of [!] in standard wildcards, i.e. it is a logical \u201cnot\u201d and will match anything not listed within the square brackets. Advanced example This command searches the file myfile for lines starting with an \u201cp\u201d and ending with an \u201ce\u201d, and prints them to the standard output. $ cat myfile | grep '^p.*e$' Remember to not include the first $ if you copy the command! It is the prompt! Keypoints Finding files with specific patterns in their names or content can be done with grep and find Regular Expressions are a type of patterns that are used when you are working with text. They can be used with grep , find , and other programs","title":"* Advanced Material - Regular Expressions"},{"location":"pipesfilters/","text":"Pipes and filters \u00b6 Learning objectives Questions How do I redirect the output? How do I pass the output from one command to another command? How do I combine multiple commands? How do I sort and filter output? What are (environment) variables? Objectives Learn how to redirect output Learn how to pass output from one command to another and combine multiple commands Learn to sort and filter the output Learn about variables and environment variables In this section we will look at redirection, pipes (for combining multiple commands), filtering output, and variables and environment variables. echo \u00b6 The echo command in Linux is a built-in command that allows users to display lines of text or strings that are passed as arguments. It is commonly used in shell scripts and batch files to output status text to the screen or a file, but can also be used to see the content of an \u201cenvironment variable\u201d or as a means to quickly send text from the command line to a file. Syntax echo [ option ] [ string ] You can find options with man echo . string is the string that we want to display or do something with. Example - try it! Display the string \u201cI am learning Linux\u201d: bbrydsoe@defiant:~$ echo \"I am learning Linux\" I am learning Linux bbrydsoe@defiant:~$ Redirection \u00b6 I/O redirection: Usually, standard input comes from the keyboard etc. and the standard output goes to the screen. There is also standard error. All of these can be redirected with Linux commands. > redirects the output of some command Example , output of \u201cls\u201d to a file: ls > test.dat >> concatenate the output of some command to the content of a \ufb01le Example , adds the output of ls to the end of a file \u201ctest.dat\u201d: ls >> test.dat < changes the standard input 2> redirects the standard error: Example , redirect the error that is thrown from your program named \u201cmyprogram\u201d to a file \u201cerror.log\u201d: ./myprogram 2> error.log 2>&1 redirects both standard output and standard error Example , redirect output and errors from your program to the same file: ./myprogram > log\ufb01le 2>&1 Some more examples HINT: code-along! cat fil.txt >> file2 Append the contents of file 1 to file2 echo 'text to append_add_here' >> file2 Append some text to a file called file2 printf \"text to append\\n\" >> fileName Another way to append some text to a file Adding longer blocks of text to a file, using the command line. HINT: code-along! Open the file for writing cat > foo.txt Add some text: This is a test. I like the Unix operating systems. The weather is nice today. I am feeling sleepy. To save the changes press CTRL-d i.e. press and hold CTRL and press d. head, tail \u00b6 head prints the first lines of a file. Usage: head -n FILE tail prints the lines at the end of a file. Usage: tail -n FILE Examples Let us use the files in the directory exercises/patterns you got from the downloaded tarball. bbrydsoe@defiant:~/exercises/patterns$ head -3 myfile3.txt Aaaand some text here as well. Should I have more lines? Probably. This is going to be a slightly longer file. bbrydsoe@defiant:~/exercises/patterns$ tail -2 myfile3.txt And more text. And just a liiiitle more text. Try it Try the two examples above. You can check with cat myfile3.txt that it is correct. wc, sort \u00b6 These are some simple and very useful commands. wc \u00b6 wc is the \u2018word count\u2019 command: it counts the number of lines, words, and characters in files (returning the values in that order from left to right). Useful -l : list number of lines per file -m : list number of characters per file -w : list number of words per file Examples I ran the examples on my work desktop \u201cdefiant\u201d. My username is \u201cbbrydsoe\u201d. Code along Code along for the examples below. We will work with the files in the directory exercises/patterns that you got from the tarball you downloaded. bbrydsoe@defiant:~/exercises/patterns$ wc myfile1.txt 4 15 80 myfile1.txt wc counted the number of lines, words, and characters in the file myfile1.txt . It says there are 4 lines , 15 words , and 80 characters . 2. bbrydsoe@defiant:~/exercises/patterns$ wc *.txt 1 6 34 fil.txt 0 0 0 myfile0.txt 4 15 80 myfile1.txt 2 10 48 myfile2.txt 7 38 203 myfile3.txt 0 0 0 myfiles.txt 0 0 0 thisfile0.txt 0 0 0 thisfile1.txt 0 0 0 thisfile2.txt 0 0 0 thisfile3.txt 0 0 0 thisfile4.txt 0 0 0 thisfile5.txt The sort command is used in Linux to print the output of a file in given order. 0 0 0 thisfile6.txt 0 0 0 thisfile7.txt 0 0 0 thisfile8.txt 0 0 0 thisfile9.txt 0 0 0 thisfile.txt 14 69 365 total All lines, words, characters in the files with the extension .txt . Also sums up the total. 3. bbrydsoe@defiant:~/exercises/patterns$ wc -l myfile2.txt 2 myfile2.txt With wc -l you only get the number of lines of the file. 4. bbrydsoe@defiant:~/exercises/patterns$ wc If you do not give a file as input, wc will assume it should wait for input. You can escape this with CTRL-C (Press the CTRL key and hold it down, then press the C key). wc - capturing output \u00b6 Assume you have a large number of files that you want to run wc on. Then it will not work well to just get the output thrown to screen. It would be much better to get the output to a file, and you can do that this way: bbrydsoe@defiant:~/exercises/patterns$ wc -l *.txt > filelength.txt This will take the number of lines for each file and put to the file filelength.txt : bbrydsoe@defiant:~/exercises/patterns$ cat filelength.txt 1 fil.txt 0 myfile0.txt 4 myfile1.txt 2 myfile2.txt 7 myfile3.txt 0 myfiles.txt 0 thisfile0.txt 0 thisfile1.txt 0 thisfile2.txt 0 thisfile3.txt 0 thisfile4.txt 0 thisfile5.txt 0 thisfile6.txt 0 thisfile7.txt 0 thisfile8.txt 0 thisfile9.txt 0 thisfile.txt 14 total In this case less might be better to use than cat if you have many files. sort \u00b6 The sort command is used in Linux to print the output of a file in given order. Useful options -n : compare according to string numerical value -f : ignore case -b : ignore leading blanks Examples Code along I suggest using the file numbers.txt in the directory exercises/patterns . Sort the file numbers.txt bbrydsoe@defiant:~/exercises/patterns$ sort numbers.txt 1 15 2 2 3 4 435 65 7 723 74 754 2. Let us try sorting with the options -n instead bbrydsoe@defiant:~/exercises/patterns$ sort -n numbers.txt 1 2 2 3 4 7 15 65 74 435 723 754 This is the difference between the default (alphanumerical) and numerical sorting. 3. What if we run sort on the output file filelength.txt we got from the section wc - capturing output above. bbrydsoe@defiant:~/exercises/patterns$ sort -n filelength.txt 0 myfile0.txt 0 myfiles.txt 0 thisfile0.txt 0 thisfile1.txt 0 thisfile2.txt 0 thisfile3.txt 0 thisfile4.txt 0 thisfile5.txt 0 thisfile6.txt 0 thisfile7.txt 0 thisfile8.txt 0 thisfile9.txt 0 thisfile.txt 1 fil.txt 2 myfile2.txt 4 myfile1.txt 7 myfile3.txt 12 numbers.txt 26 total Pipes \u00b6 Also redirection! Pipes are used when you want to take the output of one command and use it as input for another command. This is often called \u201cto pass output to another command\u201d. In many cases it is possible to do the same with an intermediate file (or more), but it is often better to just combine the commands with one or more pipes. The pipe is symbolized by a | between the commands. Examples Code along! Try code along for the three examples below. We recommend you use the files in the directory exercises/patterns to work with. Further up on the page, we counted the lines in all the files with extensions .txt and threw the output to a file. Let us instead pipe the output to sort -n so we can sort it numerically. bbrydsoe@defiant:~/exercises/patterns$ wc -l *.txt | sort -n 0 myfile0.txt 0 myfiles.txt 0 thisfile0.txt 0 thisfile1.txt 0 thisfile2.txt 0 thisfile3.txt 0 thisfile4.txt 0 thisfile5.txt 0 thisfile6.txt 0 thisfile7.txt 0 thisfile8.txt 0 thisfile9.txt 0 thisfile.txt 1 fil.txt 2 myfile2.txt 4 myfile1.txt 7 myfile3.txt 12 numbers.txt 26 total 2. We could also use tail on the output to instead see the end of the output: bbrydsoe@defiant:~/exercises/patterns$ wc -l *.txt | tail -3 0 thisfile9.txt 0 thisfile.txt 26 total 3. Or we could combine several commands, and sort the output of wc and then run head on that output: bbrydsoe@defiant:~/exercises/patterns$ wc -l *.txt | sort -n | head -3 0 myfile0.txt 0 myfiles.txt 0 thisfile0.txt bbrydsoe@defiant:~/exercises/patterns$ Exporting variables \u00b6 Variables can be very useful. Environment variables store data that is used by the operating system and other programs. Some are intrinsic to the operating system, some for a specific program/library/programming language, and some are created by the user. The variables can both be used in scripts and on the command line. Usually you reference them by putting a special symbol in front of or around the variable name. By convention, environment variable names are in UPPER CASE. Examples: $HOME Your home directory $PWD This variable points to your current directory $LD_LIBRARY_PATH a colon-separated list of directories that the dynamic linker should search for shared objects before searching in any other directories $OMP_NUM_THREADS Number of OpenMP threads $PYTHONPATH Path to the directory where your Python libraries and packages are installed To see the content of an environment variable named ENVIRONMENT_VARIABLE echo $ENVIRONMENT_VARIABLE Tip You will get a long list of all environment variables currently set with the command: env Some environment variables need to be exported in order to be used This is how you set the environment variable VARIABLE to value: For the bash shell export VARIABLE = value For csh and related shells setenv VARIABLE value You can create your own variables to use, for instance in scripts. More about that under the section scripting . Some examples: Setting the number of OpenMP threads to 8 in bash export OMP_NUM_THREADS = 8 Adding a new path to $LD_LIBRARY_PATH export LD_LIBRARY_PATH = $LD_LIBRARY_PATH :/your/custom/path/ Warning The environment variable only retains the value you have set for the duration of the session. When you open a new terminal window or login again, you need to set it again. To avoid that, add it to your .bashrc file, but only do so if it should truly be persisten across many sessions (like adding a new directory to search to LD_LIBRARY_PATH for instance). Quickly add a new directory to LD_LIBRARY_PATH in your .bashrc echo \"export LD_LIBRARY_PATH= $LD_LIBRARY_PATH :/your/custom/path/\" >> ~/.bashrc Change /your/custom/path/ to the actual path to the directory for your library. Keypoints echo is used to print output of a string or an environment variable redirection is used to redirect the output of a command the output of one command can be passed to another command the command wc can be used to count words, lines, or characters the command sort is used to sort input pipes are used when passing the output of one command to another command. It is show as | environment variables are used to store data that is used by the operating system and other programs Some common environment variables are: $HOME Your home directory $PWD This variable points to your current directory $LD_LIBRARY_PATH a colon-separated list of directories that the dynamic linker should search for shared objects before searching in any other directories $OMP_NUM_THREADS Number of OpenMP threads $PYTHONPATH Path to the directory where your Python libraries and packages are installed","title":"Piping"},{"location":"pipesfilters/#pipes__and__filters","text":"Learning objectives Questions How do I redirect the output? How do I pass the output from one command to another command? How do I combine multiple commands? How do I sort and filter output? What are (environment) variables? Objectives Learn how to redirect output Learn how to pass output from one command to another and combine multiple commands Learn to sort and filter the output Learn about variables and environment variables In this section we will look at redirection, pipes (for combining multiple commands), filtering output, and variables and environment variables.","title":"Pipes and filters"},{"location":"pipesfilters/#echo","text":"The echo command in Linux is a built-in command that allows users to display lines of text or strings that are passed as arguments. It is commonly used in shell scripts and batch files to output status text to the screen or a file, but can also be used to see the content of an \u201cenvironment variable\u201d or as a means to quickly send text from the command line to a file. Syntax echo [ option ] [ string ] You can find options with man echo . string is the string that we want to display or do something with. Example - try it! Display the string \u201cI am learning Linux\u201d: bbrydsoe@defiant:~$ echo \"I am learning Linux\" I am learning Linux bbrydsoe@defiant:~$","title":"echo"},{"location":"pipesfilters/#redirection","text":"I/O redirection: Usually, standard input comes from the keyboard etc. and the standard output goes to the screen. There is also standard error. All of these can be redirected with Linux commands. > redirects the output of some command Example , output of \u201cls\u201d to a file: ls > test.dat >> concatenate the output of some command to the content of a \ufb01le Example , adds the output of ls to the end of a file \u201ctest.dat\u201d: ls >> test.dat < changes the standard input 2> redirects the standard error: Example , redirect the error that is thrown from your program named \u201cmyprogram\u201d to a file \u201cerror.log\u201d: ./myprogram 2> error.log 2>&1 redirects both standard output and standard error Example , redirect output and errors from your program to the same file: ./myprogram > log\ufb01le 2>&1 Some more examples HINT: code-along! cat fil.txt >> file2 Append the contents of file 1 to file2 echo 'text to append_add_here' >> file2 Append some text to a file called file2 printf \"text to append\\n\" >> fileName Another way to append some text to a file Adding longer blocks of text to a file, using the command line. HINT: code-along! Open the file for writing cat > foo.txt Add some text: This is a test. I like the Unix operating systems. The weather is nice today. I am feeling sleepy. To save the changes press CTRL-d i.e. press and hold CTRL and press d.","title":"Redirection"},{"location":"pipesfilters/#head__tail","text":"head prints the first lines of a file. Usage: head -n FILE tail prints the lines at the end of a file. Usage: tail -n FILE Examples Let us use the files in the directory exercises/patterns you got from the downloaded tarball. bbrydsoe@defiant:~/exercises/patterns$ head -3 myfile3.txt Aaaand some text here as well. Should I have more lines? Probably. This is going to be a slightly longer file. bbrydsoe@defiant:~/exercises/patterns$ tail -2 myfile3.txt And more text. And just a liiiitle more text. Try it Try the two examples above. You can check with cat myfile3.txt that it is correct.","title":"head, tail"},{"location":"pipesfilters/#wc__sort","text":"These are some simple and very useful commands.","title":"wc, sort"},{"location":"pipesfilters/#wc","text":"wc is the \u2018word count\u2019 command: it counts the number of lines, words, and characters in files (returning the values in that order from left to right). Useful -l : list number of lines per file -m : list number of characters per file -w : list number of words per file Examples I ran the examples on my work desktop \u201cdefiant\u201d. My username is \u201cbbrydsoe\u201d. Code along Code along for the examples below. We will work with the files in the directory exercises/patterns that you got from the tarball you downloaded. bbrydsoe@defiant:~/exercises/patterns$ wc myfile1.txt 4 15 80 myfile1.txt wc counted the number of lines, words, and characters in the file myfile1.txt . It says there are 4 lines , 15 words , and 80 characters . 2. bbrydsoe@defiant:~/exercises/patterns$ wc *.txt 1 6 34 fil.txt 0 0 0 myfile0.txt 4 15 80 myfile1.txt 2 10 48 myfile2.txt 7 38 203 myfile3.txt 0 0 0 myfiles.txt 0 0 0 thisfile0.txt 0 0 0 thisfile1.txt 0 0 0 thisfile2.txt 0 0 0 thisfile3.txt 0 0 0 thisfile4.txt 0 0 0 thisfile5.txt The sort command is used in Linux to print the output of a file in given order. 0 0 0 thisfile6.txt 0 0 0 thisfile7.txt 0 0 0 thisfile8.txt 0 0 0 thisfile9.txt 0 0 0 thisfile.txt 14 69 365 total All lines, words, characters in the files with the extension .txt . Also sums up the total. 3. bbrydsoe@defiant:~/exercises/patterns$ wc -l myfile2.txt 2 myfile2.txt With wc -l you only get the number of lines of the file. 4. bbrydsoe@defiant:~/exercises/patterns$ wc If you do not give a file as input, wc will assume it should wait for input. You can escape this with CTRL-C (Press the CTRL key and hold it down, then press the C key).","title":"wc"},{"location":"pipesfilters/#wc__-__capturing__output","text":"Assume you have a large number of files that you want to run wc on. Then it will not work well to just get the output thrown to screen. It would be much better to get the output to a file, and you can do that this way: bbrydsoe@defiant:~/exercises/patterns$ wc -l *.txt > filelength.txt This will take the number of lines for each file and put to the file filelength.txt : bbrydsoe@defiant:~/exercises/patterns$ cat filelength.txt 1 fil.txt 0 myfile0.txt 4 myfile1.txt 2 myfile2.txt 7 myfile3.txt 0 myfiles.txt 0 thisfile0.txt 0 thisfile1.txt 0 thisfile2.txt 0 thisfile3.txt 0 thisfile4.txt 0 thisfile5.txt 0 thisfile6.txt 0 thisfile7.txt 0 thisfile8.txt 0 thisfile9.txt 0 thisfile.txt 14 total In this case less might be better to use than cat if you have many files.","title":"wc - capturing output"},{"location":"pipesfilters/#sort","text":"The sort command is used in Linux to print the output of a file in given order. Useful options -n : compare according to string numerical value -f : ignore case -b : ignore leading blanks Examples Code along I suggest using the file numbers.txt in the directory exercises/patterns . Sort the file numbers.txt bbrydsoe@defiant:~/exercises/patterns$ sort numbers.txt 1 15 2 2 3 4 435 65 7 723 74 754 2. Let us try sorting with the options -n instead bbrydsoe@defiant:~/exercises/patterns$ sort -n numbers.txt 1 2 2 3 4 7 15 65 74 435 723 754 This is the difference between the default (alphanumerical) and numerical sorting. 3. What if we run sort on the output file filelength.txt we got from the section wc - capturing output above. bbrydsoe@defiant:~/exercises/patterns$ sort -n filelength.txt 0 myfile0.txt 0 myfiles.txt 0 thisfile0.txt 0 thisfile1.txt 0 thisfile2.txt 0 thisfile3.txt 0 thisfile4.txt 0 thisfile5.txt 0 thisfile6.txt 0 thisfile7.txt 0 thisfile8.txt 0 thisfile9.txt 0 thisfile.txt 1 fil.txt 2 myfile2.txt 4 myfile1.txt 7 myfile3.txt 12 numbers.txt 26 total","title":"sort"},{"location":"pipesfilters/#pipes","text":"Also redirection! Pipes are used when you want to take the output of one command and use it as input for another command. This is often called \u201cto pass output to another command\u201d. In many cases it is possible to do the same with an intermediate file (or more), but it is often better to just combine the commands with one or more pipes. The pipe is symbolized by a | between the commands. Examples Code along! Try code along for the three examples below. We recommend you use the files in the directory exercises/patterns to work with. Further up on the page, we counted the lines in all the files with extensions .txt and threw the output to a file. Let us instead pipe the output to sort -n so we can sort it numerically. bbrydsoe@defiant:~/exercises/patterns$ wc -l *.txt | sort -n 0 myfile0.txt 0 myfiles.txt 0 thisfile0.txt 0 thisfile1.txt 0 thisfile2.txt 0 thisfile3.txt 0 thisfile4.txt 0 thisfile5.txt 0 thisfile6.txt 0 thisfile7.txt 0 thisfile8.txt 0 thisfile9.txt 0 thisfile.txt 1 fil.txt 2 myfile2.txt 4 myfile1.txt 7 myfile3.txt 12 numbers.txt 26 total 2. We could also use tail on the output to instead see the end of the output: bbrydsoe@defiant:~/exercises/patterns$ wc -l *.txt | tail -3 0 thisfile9.txt 0 thisfile.txt 26 total 3. Or we could combine several commands, and sort the output of wc and then run head on that output: bbrydsoe@defiant:~/exercises/patterns$ wc -l *.txt | sort -n | head -3 0 myfile0.txt 0 myfiles.txt 0 thisfile0.txt bbrydsoe@defiant:~/exercises/patterns$","title":"Pipes"},{"location":"pipesfilters/#exporting__variables","text":"Variables can be very useful. Environment variables store data that is used by the operating system and other programs. Some are intrinsic to the operating system, some for a specific program/library/programming language, and some are created by the user. The variables can both be used in scripts and on the command line. Usually you reference them by putting a special symbol in front of or around the variable name. By convention, environment variable names are in UPPER CASE. Examples: $HOME Your home directory $PWD This variable points to your current directory $LD_LIBRARY_PATH a colon-separated list of directories that the dynamic linker should search for shared objects before searching in any other directories $OMP_NUM_THREADS Number of OpenMP threads $PYTHONPATH Path to the directory where your Python libraries and packages are installed To see the content of an environment variable named ENVIRONMENT_VARIABLE echo $ENVIRONMENT_VARIABLE Tip You will get a long list of all environment variables currently set with the command: env Some environment variables need to be exported in order to be used This is how you set the environment variable VARIABLE to value: For the bash shell export VARIABLE = value For csh and related shells setenv VARIABLE value You can create your own variables to use, for instance in scripts. More about that under the section scripting . Some examples: Setting the number of OpenMP threads to 8 in bash export OMP_NUM_THREADS = 8 Adding a new path to $LD_LIBRARY_PATH export LD_LIBRARY_PATH = $LD_LIBRARY_PATH :/your/custom/path/ Warning The environment variable only retains the value you have set for the duration of the session. When you open a new terminal window or login again, you need to set it again. To avoid that, add it to your .bashrc file, but only do so if it should truly be persisten across many sessions (like adding a new directory to search to LD_LIBRARY_PATH for instance). Quickly add a new directory to LD_LIBRARY_PATH in your .bashrc echo \"export LD_LIBRARY_PATH= $LD_LIBRARY_PATH :/your/custom/path/\" >> ~/.bashrc Change /your/custom/path/ to the actual path to the directory for your library. Keypoints echo is used to print output of a string or an environment variable redirection is used to redirect the output of a command the output of one command can be passed to another command the command wc can be used to count words, lines, or characters the command sort is used to sort input pipes are used when passing the output of one command to another command. It is show as | environment variables are used to store data that is used by the operating system and other programs Some common environment variables are: $HOME Your home directory $PWD This variable points to your current directory $LD_LIBRARY_PATH a colon-separated list of directories that the dynamic linker should search for shared objects before searching in any other directories $OMP_NUM_THREADS Number of OpenMP threads $PYTHONPATH Path to the directory where your Python libraries and packages are installed","title":"Exporting variables"},{"location":"scripting/","text":"Scripting \u00b6 Learning objectives Questions What is a script? What are file permissions? How do I write a script? How do I execute a script? Objectives Learn how to make a simple script Get a brief introduction to permissions This section will look at scripting. Scripting is used to perform complex or repetitive tasks without user intervention. All Linux commands which can be used on the commandline can also be used inside a script, including wild cards. The most common reason for making a script is probably to avoid writing the same command again and again. On an HPC-sytem, such as the ones offered by NAISS, scripts are required to execute Linux commands and programs inside the batch system. Code along! Try out or code along for some of these examples. You can use the contents of the directory /exercises/script that you got from the downloaded tarball ( exercises.tar.gz ) to play with. If you have not done so already, right-click and save to download, or right-click and copy the url, then do wget THE-URL-YOU-COPIED in a terminal window to download it there. Then do tar -zxvf patterns.tar.gz to unpack. Starting with a motivational example \u00b6 We start scripting with a simple example. The task at hand is to check how many lines of the file file.dat contain the string \u2018ABCD\u2019. This time we want to do this with a script. Example Use an editor, e.g. nano to create the file my_first.sh . The file should contain the following: #!/bin/bash grep 'ABCD' file.dat > file_filtered.dat wc -l < file_filtered.dat > output.dat With the following command, which will be explained in-depth further down, we can make the script executable $ chmod u+x my_first.sh Now we can execute the script: $ ./my_first.sh You should get the number 2 as a result. Confirm this by looking into the file file.dat . With a single line we executed both commands grep and wc . What it does First line of the script: telling the system it should be executed in the bash shell, since commands differ between shells (the program loader is told to run the program /bin/bash as first argument). #! are called shebang . This has to be the first line. second line: search for the string ABCD in the file file.dat , then redirect the output to the file file_filtered.dat third line: run the command wc -l with the file file_filtered.dat as input. It then redirects the output to the file output.dat . We can now execute two Linux commands with a single line. Permissions \u00b6 We have used the command chmod in the above example. Note The command chmod is used to change permissions for files and directories. Permissions are needed to, among other things, make a file executable. Let us take a look at an example When running the command ls -la you should get an output similar to the below: $ ls -la total 64 drwxr-xr-x 11 joachim staff 352 Sep 29 16 :47 . drwxr-xr-x 6 joachim staff 192 Sep 29 16 :29 .. -rwxr-xr-x 1 joachim staff 99 Sep 29 17 :30 analysis.sh -rw-r--r-- 1 joachim staff 120 Sep 29 17 :30 file.dat -rw-r--r-- 1 joachim staff 128 Sep 29 17 :30 file.txt -rw-r--r-- 1 joachim staff 188 Sep 29 17 :30 file2.dat -rw-r--r-- 1 joachim staff 54 Sep 29 17 :30 filtered_file.dat drwxr-xr-x 13 joachim staff 416 Sep 29 17 :30 image -rwxr-xr-x 1 joachim staff 153 Sep 29 17 :30 imagefind.sh -rwxr--r-- 1 joachim staff 80 Sep 29 17 :30 my_first.sh -rwxr-xr-x 1 joachim staff 9 Sep 29 17 :30 program.sh If you look at the left-most column, you see an example of permissions . There are three types of permission groups owners : these permissions will only apply to owners and will not affect other groups. groups : you can assign a group of users specific permissions, which will only impact users within the group. The members of your storage directory belongs here. all users : these permissions will apply to all users, so be careful with this. There are three kinds of file permissions Read (r): This allows a user or a group to view a file (and so also to copy it). Write (w): This permits the user to write or modify a file or directory. Execute (x): A user or a group with execute permissions can execute a file. They can also view a subdirectory. The permissions for a file, directory, or symbolic link has 10 \u201cbits\u201d and looks similar to this: As shown, the first bit can be \u201c-\u201d (a file), \u201cd\u201d (a directory), or \u201cl\u201d (a link). The following group of 3 bits are for the owner, then the next 3 for the group, and then the last 3 for all users. Each can have the r(ead), w(rite), and (e)x(ecute) permission set. To change permissions, here are some examples owner (user) chmod u+rwx FILE/DIR to add all permissions of a file with name FILE or a directory with name DIR chmod u-rwx FILE/DIR to remove all permissions from a file with name FILE or a directory with name DIR chmod u+x FILE to add executable permissions chmod u-wx FILE to remove write and executable permissions group chmod g+rwx FILE to add all permissions to FILE chmod g-rwx FILE to remove all permissions to FILE chmod g+wx FILE to give write and execute permissions to FILE chmod g-x FILE to remove execute permissions to FILE others chmod o+rwx FILE to add all permissions to FILE chmod o-rwx FILE to remove all permissions to FILE chmod o+w FILE to add write permissions to FILE chmod o-rwx DIR to remove all permissions to DIR all chmod ugo+rwx FILE/DIR to add all permissions for all users (owner, group, others) to file named FILE or directory named DIR chmod a=rwx FILE/DIR same as above chmod a=r DIR give read permissions to all for DIR Note It is also possible to change the ownership of a file or a directory. We are not going to cover this here, but you can read about the command chown and how to use it in the \u201c More commands \u201d section under EXTRAS. More scripting \u00b6 Scripting is used to perform complex or repetitive tasks without user intervention. All Linux commands can be used in a script including wild cards. Note If it is just a one-line command you want to do again and again, then \u2018alias\u2019 is more suited for this. We go back to our example script my_first.sh . There is a second file named file2.dat which also needs to be processed by the script. We could open an editor, change the contents of my_first.sh and re-run it. This is not really convenient. To create an improved script copy your script $ cp my_first.sh count_ABCD.sh and open the file count_ABCD.sh in an editor. Change the argument of grep from file.dat to $1 #!/bin/bash grep 'ABCD' $1 > file_filtered.dat wc -l < file_filtered.dat Check that count_ABCD.sh has executable permissions and executed the script as follows: $ ./count_ABCD.sh file.dat This should give the same result of 2 as before. When running the script count_ABCD.sh the $1 gets replaced with the first argument you write after the name of the script. The file file2.dat can now be processed without changing the script: $ ./count_ABCD.sh file2.dat You should get 3 for the result. We now might want to upgrade that we can search for another string than \u201cABCD\u201d. We copy $ cp count_ABCD.sh count_string.sh and edit count_string.sh to become: #!/bin/bash grep $2 $1 > file_filtered.dat wc -l < file_filtered.dat We can now search for \u2018ABCD\u2019 in both files: $ ./count_string.sh file.dat ABCD 2 $ ./count_string.sh file2.dat ABCD 3 alternatively you can search for the word \u2018line\u2019 by changing the input at the prompt $ ./count_string.sh file.dat line 1 $ ./count_string.sh file2.dat line 3 Commenting \u00b6 It is useful to write comments into your script, to make their actions more understandable when e.g. you need to understand them in the future or want to share the with someone else. Note Bash treats lines starting with a # as a comment. Obviously this excludes the shebang in the first line of the script. Open count_string.sh in an editor and add comments Commented version of count_string.sh #!/bin/bash # return number of lines in a file containing a string # usage: ./count_string file_name string # search for lines with the string in the file grep $2 $1 > file_filtered.dat # count the number of lines wc -l < file_filtered.dat More advanced examples \u00b6 Execute a command on the output of find This example script imagefind.sh will find all files with the extention .png in $HOME/exercises/script/image and then copy them to a directory named myimages . Then it searches for files with er as part of the name and redirects the output to a file named someimagesfiles.txt #!/bin/bash find $HOME /exercises/script/image -type f -name \"*.png\" -exec cp {} myimages \\; find myimages -type f -name \"*er*\" > someimagesfiles.txt Execute a command on output of find and loop over output files This example script will find all files with extension .eps in the current directory (and below) and then copy them to the directory figures . Afterwards it creates a variable FIGFILES that contains the full path to the directory with the figures, and all the files in it. Then follows a loop over all files. Inside the loop we convert .eps files to .pdf files. The extra line before is just a way to avoid the newly created .pdf files ends up with extension .eps.pdf . #!/bin/bash find . -type f -name \"*.eps\" -exec cp {} $HOME /figures \\; FIGFILES = \" $HOME /figures/*\" for f in $FIGFILES do g = ${ f %.* } ps2pdf -DEPSCrop \" $f \" \" $g .pdf\" done For more examples of (more useful) scripts, see for instance this list of 25 Easy Bash Script Examples . Keypoints You change permissions for files and directories with chmod Scripting is used to perform complex or repetitive tasks without user intervention. All Linux commands can be used in a script including wild cards.","title":"Scripting"},{"location":"scripting/#scripting","text":"Learning objectives Questions What is a script? What are file permissions? How do I write a script? How do I execute a script? Objectives Learn how to make a simple script Get a brief introduction to permissions This section will look at scripting. Scripting is used to perform complex or repetitive tasks without user intervention. All Linux commands which can be used on the commandline can also be used inside a script, including wild cards. The most common reason for making a script is probably to avoid writing the same command again and again. On an HPC-sytem, such as the ones offered by NAISS, scripts are required to execute Linux commands and programs inside the batch system. Code along! Try out or code along for some of these examples. You can use the contents of the directory /exercises/script that you got from the downloaded tarball ( exercises.tar.gz ) to play with. If you have not done so already, right-click and save to download, or right-click and copy the url, then do wget THE-URL-YOU-COPIED in a terminal window to download it there. Then do tar -zxvf patterns.tar.gz to unpack.","title":"Scripting"},{"location":"scripting/#starting__with__a__motivational__example","text":"We start scripting with a simple example. The task at hand is to check how many lines of the file file.dat contain the string \u2018ABCD\u2019. This time we want to do this with a script. Example Use an editor, e.g. nano to create the file my_first.sh . The file should contain the following: #!/bin/bash grep 'ABCD' file.dat > file_filtered.dat wc -l < file_filtered.dat > output.dat With the following command, which will be explained in-depth further down, we can make the script executable $ chmod u+x my_first.sh Now we can execute the script: $ ./my_first.sh You should get the number 2 as a result. Confirm this by looking into the file file.dat . With a single line we executed both commands grep and wc . What it does First line of the script: telling the system it should be executed in the bash shell, since commands differ between shells (the program loader is told to run the program /bin/bash as first argument). #! are called shebang . This has to be the first line. second line: search for the string ABCD in the file file.dat , then redirect the output to the file file_filtered.dat third line: run the command wc -l with the file file_filtered.dat as input. It then redirects the output to the file output.dat . We can now execute two Linux commands with a single line.","title":"Starting with a motivational example"},{"location":"scripting/#permissions","text":"We have used the command chmod in the above example. Note The command chmod is used to change permissions for files and directories. Permissions are needed to, among other things, make a file executable. Let us take a look at an example When running the command ls -la you should get an output similar to the below: $ ls -la total 64 drwxr-xr-x 11 joachim staff 352 Sep 29 16 :47 . drwxr-xr-x 6 joachim staff 192 Sep 29 16 :29 .. -rwxr-xr-x 1 joachim staff 99 Sep 29 17 :30 analysis.sh -rw-r--r-- 1 joachim staff 120 Sep 29 17 :30 file.dat -rw-r--r-- 1 joachim staff 128 Sep 29 17 :30 file.txt -rw-r--r-- 1 joachim staff 188 Sep 29 17 :30 file2.dat -rw-r--r-- 1 joachim staff 54 Sep 29 17 :30 filtered_file.dat drwxr-xr-x 13 joachim staff 416 Sep 29 17 :30 image -rwxr-xr-x 1 joachim staff 153 Sep 29 17 :30 imagefind.sh -rwxr--r-- 1 joachim staff 80 Sep 29 17 :30 my_first.sh -rwxr-xr-x 1 joachim staff 9 Sep 29 17 :30 program.sh If you look at the left-most column, you see an example of permissions . There are three types of permission groups owners : these permissions will only apply to owners and will not affect other groups. groups : you can assign a group of users specific permissions, which will only impact users within the group. The members of your storage directory belongs here. all users : these permissions will apply to all users, so be careful with this. There are three kinds of file permissions Read (r): This allows a user or a group to view a file (and so also to copy it). Write (w): This permits the user to write or modify a file or directory. Execute (x): A user or a group with execute permissions can execute a file. They can also view a subdirectory. The permissions for a file, directory, or symbolic link has 10 \u201cbits\u201d and looks similar to this: As shown, the first bit can be \u201c-\u201d (a file), \u201cd\u201d (a directory), or \u201cl\u201d (a link). The following group of 3 bits are for the owner, then the next 3 for the group, and then the last 3 for all users. Each can have the r(ead), w(rite), and (e)x(ecute) permission set. To change permissions, here are some examples owner (user) chmod u+rwx FILE/DIR to add all permissions of a file with name FILE or a directory with name DIR chmod u-rwx FILE/DIR to remove all permissions from a file with name FILE or a directory with name DIR chmod u+x FILE to add executable permissions chmod u-wx FILE to remove write and executable permissions group chmod g+rwx FILE to add all permissions to FILE chmod g-rwx FILE to remove all permissions to FILE chmod g+wx FILE to give write and execute permissions to FILE chmod g-x FILE to remove execute permissions to FILE others chmod o+rwx FILE to add all permissions to FILE chmod o-rwx FILE to remove all permissions to FILE chmod o+w FILE to add write permissions to FILE chmod o-rwx DIR to remove all permissions to DIR all chmod ugo+rwx FILE/DIR to add all permissions for all users (owner, group, others) to file named FILE or directory named DIR chmod a=rwx FILE/DIR same as above chmod a=r DIR give read permissions to all for DIR Note It is also possible to change the ownership of a file or a directory. We are not going to cover this here, but you can read about the command chown and how to use it in the \u201c More commands \u201d section under EXTRAS.","title":"Permissions"},{"location":"scripting/#more__scripting","text":"Scripting is used to perform complex or repetitive tasks without user intervention. All Linux commands can be used in a script including wild cards. Note If it is just a one-line command you want to do again and again, then \u2018alias\u2019 is more suited for this. We go back to our example script my_first.sh . There is a second file named file2.dat which also needs to be processed by the script. We could open an editor, change the contents of my_first.sh and re-run it. This is not really convenient. To create an improved script copy your script $ cp my_first.sh count_ABCD.sh and open the file count_ABCD.sh in an editor. Change the argument of grep from file.dat to $1 #!/bin/bash grep 'ABCD' $1 > file_filtered.dat wc -l < file_filtered.dat Check that count_ABCD.sh has executable permissions and executed the script as follows: $ ./count_ABCD.sh file.dat This should give the same result of 2 as before. When running the script count_ABCD.sh the $1 gets replaced with the first argument you write after the name of the script. The file file2.dat can now be processed without changing the script: $ ./count_ABCD.sh file2.dat You should get 3 for the result. We now might want to upgrade that we can search for another string than \u201cABCD\u201d. We copy $ cp count_ABCD.sh count_string.sh and edit count_string.sh to become: #!/bin/bash grep $2 $1 > file_filtered.dat wc -l < file_filtered.dat We can now search for \u2018ABCD\u2019 in both files: $ ./count_string.sh file.dat ABCD 2 $ ./count_string.sh file2.dat ABCD 3 alternatively you can search for the word \u2018line\u2019 by changing the input at the prompt $ ./count_string.sh file.dat line 1 $ ./count_string.sh file2.dat line 3","title":"More scripting"},{"location":"scripting/#commenting","text":"It is useful to write comments into your script, to make their actions more understandable when e.g. you need to understand them in the future or want to share the with someone else. Note Bash treats lines starting with a # as a comment. Obviously this excludes the shebang in the first line of the script. Open count_string.sh in an editor and add comments Commented version of count_string.sh #!/bin/bash # return number of lines in a file containing a string # usage: ./count_string file_name string # search for lines with the string in the file grep $2 $1 > file_filtered.dat # count the number of lines wc -l < file_filtered.dat","title":"Commenting"},{"location":"scripting/#more__advanced__examples","text":"Execute a command on the output of find This example script imagefind.sh will find all files with the extention .png in $HOME/exercises/script/image and then copy them to a directory named myimages . Then it searches for files with er as part of the name and redirects the output to a file named someimagesfiles.txt #!/bin/bash find $HOME /exercises/script/image -type f -name \"*.png\" -exec cp {} myimages \\; find myimages -type f -name \"*er*\" > someimagesfiles.txt Execute a command on output of find and loop over output files This example script will find all files with extension .eps in the current directory (and below) and then copy them to the directory figures . Afterwards it creates a variable FIGFILES that contains the full path to the directory with the figures, and all the files in it. Then follows a loop over all files. Inside the loop we convert .eps files to .pdf files. The extra line before is just a way to avoid the newly created .pdf files ends up with extension .eps.pdf . #!/bin/bash find . -type f -name \"*.eps\" -exec cp {} $HOME /figures \\; FIGFILES = \" $HOME /figures/*\" for f in $FIGFILES do g = ${ f %.* } ps2pdf -DEPSCrop \" $f \" \" $g .pdf\" done For more examples of (more useful) scripts, see for instance this list of 25 Easy Bash Script Examples . Keypoints You change permissions for files and directories with chmod Scripting is used to perform complex or repetitive tasks without user intervention. All Linux commands can be used in a script including wild cards.","title":"More advanced examples"},{"location":"summary/","text":"Summary \u00b6 Keypoints The command line (CLI) an interface for typing commands directly to a computer\u2019s operating system. often gives access to many more capabilities than the graphical user interface does. practical and normally faster in situations where you login with a terminal on a remote system. The File System directory structure starts with the top root directory, shown as / . several standard subdirectories: /usr/bin , /home , /usr/lib , /usr/lib64 , and /usr/local/bin . important commands: ls: lists files/directories cd: change directory chmod: change permissions mkdir: create directory rm: remove files or directories cp: copy files or directories mv: move or rename files or directories IMPORTANT remember the -i option of rm, cp and mv to avoid loosing contents symbolic link: pointer to another file or directory Pipes and filters less, more, cat echo redirection wc, sort pipes environment variables: stores data that is used by the operating system and other programs. Can be exported and referenced. Editors command-line: nano, vim, emacs gui: gedit, pluma, emacs Patterns and scripting finding patterns grep, find wild cards regular expressions scripting Hints and tricks auto-complete short-cuts alias finding help Extra We have some advanced material in EXTRAS , for you to study on your own. Questions Ask the instructors now Send questions to support: https://supr.naiss.se/support/ More information The Linux Handbook: https://linuxhandbook.com/ Linux Tutorial: https://www.geeksforgeeks.org/linux-tutorial/ 14 Free Training Courses to Learn Linux Online: https://itsfoss.com/free-linux-training-courses/ Introduction to Linux - A Hands on Guide: https://tldp.org/LDP/intro-linux/intro-linux.pdf Linux Fundamentals: https://cloudacademy.com/course/linux-fundmentals-1346/the-linux-directory-structure/ Top 50+ Linux Commands You MUST Know: https://www.digitalocean.com/community/tutorials/linux-commands Glossary of Linux Terms: https://www.miralishahidi.ir/resources/Linux%20Terminology%20Glossary.pdf Linux on Wikipedia: https://en.wikipedia.org/wiki/Linux 25 Easy Bash Script Examples: https://www.hostinger.com/tutorials/bash-script-example HPC2N: https://docs.hpc2n.umu.se/tutorials/linuxguide/ UPPMAX: https://docs.uppmax.uu.se/getting_started/linux/ LUNARC: https://lunarc-documentation.readthedocs.io/en/latest/guides/linux/linux_basics_intro/ PDC: https://www.pdc.kth.se/support/documents/basics/introduction.html#basic-linux-for-new-hpc-users HPC2N docs: https://docs.hpc2n.umu.se/","title":"Summary"},{"location":"summary/#summary","text":"Keypoints The command line (CLI) an interface for typing commands directly to a computer\u2019s operating system. often gives access to many more capabilities than the graphical user interface does. practical and normally faster in situations where you login with a terminal on a remote system. The File System directory structure starts with the top root directory, shown as / . several standard subdirectories: /usr/bin , /home , /usr/lib , /usr/lib64 , and /usr/local/bin . important commands: ls: lists files/directories cd: change directory chmod: change permissions mkdir: create directory rm: remove files or directories cp: copy files or directories mv: move or rename files or directories IMPORTANT remember the -i option of rm, cp and mv to avoid loosing contents symbolic link: pointer to another file or directory Pipes and filters less, more, cat echo redirection wc, sort pipes environment variables: stores data that is used by the operating system and other programs. Can be exported and referenced. Editors command-line: nano, vim, emacs gui: gedit, pluma, emacs Patterns and scripting finding patterns grep, find wild cards regular expressions scripting Hints and tricks auto-complete short-cuts alias finding help Extra We have some advanced material in EXTRAS , for you to study on your own. Questions Ask the instructors now Send questions to support: https://supr.naiss.se/support/ More information The Linux Handbook: https://linuxhandbook.com/ Linux Tutorial: https://www.geeksforgeeks.org/linux-tutorial/ 14 Free Training Courses to Learn Linux Online: https://itsfoss.com/free-linux-training-courses/ Introduction to Linux - A Hands on Guide: https://tldp.org/LDP/intro-linux/intro-linux.pdf Linux Fundamentals: https://cloudacademy.com/course/linux-fundmentals-1346/the-linux-directory-structure/ Top 50+ Linux Commands You MUST Know: https://www.digitalocean.com/community/tutorials/linux-commands Glossary of Linux Terms: https://www.miralishahidi.ir/resources/Linux%20Terminology%20Glossary.pdf Linux on Wikipedia: https://en.wikipedia.org/wiki/Linux 25 Easy Bash Script Examples: https://www.hostinger.com/tutorials/bash-script-example HPC2N: https://docs.hpc2n.umu.se/tutorials/linuxguide/ UPPMAX: https://docs.uppmax.uu.se/getting_started/linux/ LUNARC: https://lunarc-documentation.readthedocs.io/en/latest/guides/linux/linux_basics_intro/ PDC: https://www.pdc.kth.se/support/documents/basics/introduction.html#basic-linux-for-new-hpc-users HPC2N docs: https://docs.hpc2n.umu.se/","title":"Summary"},{"location":"tree/","text":"tree \u00b6 Install and run tree as not-root on an Ubuntu Linux system where it is not installed. Create a directory to work in: mkdir ~/tree Change to that directory: cd ~/tree Download tree: apt download tree Extract the files: dpkg-deb -xv ./*deb ./ Now you can run the tree command by giving the full path: ~/tree/usr/bin/tree In order to run it without having to give the full path, create an alias in your ~/.bashrc file: 1. Open ~/.bashrc without your favourite editor. 2. Add this line at the end or with your other alias\u2019es: alias tree = \" $HOME /tree/usr/bin/tree\" 3. Save the file. 4. source the file: source ~/.bashrc You can now run tree by just giving the command tree .","title":"Install tree"},{"location":"tree/#tree","text":"Install and run tree as not-root on an Ubuntu Linux system where it is not installed. Create a directory to work in: mkdir ~/tree Change to that directory: cd ~/tree Download tree: apt download tree Extract the files: dpkg-deb -xv ./*deb ./ Now you can run the tree command by giving the full path: ~/tree/usr/bin/tree In order to run it without having to give the full path, create an alias in your ~/.bashrc file: 1. Open ~/.bashrc without your favourite editor. 2. Add this line at the end or with your other alias\u2019es: alias tree = \" $HOME /tree/usr/bin/tree\" 3. Save the file. 4. source the file: source ~/.bashrc You can now run tree by just giving the command tree .","title":"tree"}]}